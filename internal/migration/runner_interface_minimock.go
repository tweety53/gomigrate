package migration

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/tweety53/gomigrate/internal/repo"
)

// RunnerInterfaceMock implements RunnerInterface
type RunnerInterfaceMock struct {
	t minimock.Tester

	funcMigrateDown          func(repo repo.MigrationRepo, m *Migration) (err error)
	inspectFuncMigrateDown   func(repo repo.MigrationRepo, m *Migration)
	afterMigrateDownCounter  uint64
	beforeMigrateDownCounter uint64
	MigrateDownMock          mRunnerInterfaceMockMigrateDown

	funcMigrateDownSafe          func(repo repo.MigrationRepo, m *Migration) (err error)
	inspectFuncMigrateDownSafe   func(repo repo.MigrationRepo, m *Migration)
	afterMigrateDownSafeCounter  uint64
	beforeMigrateDownSafeCounter uint64
	MigrateDownSafeMock          mRunnerInterfaceMockMigrateDownSafe

	funcMigrateUp          func(repo repo.MigrationRepo, m *Migration) (err error)
	inspectFuncMigrateUp   func(repo repo.MigrationRepo, m *Migration)
	afterMigrateUpCounter  uint64
	beforeMigrateUpCounter uint64
	MigrateUpMock          mRunnerInterfaceMockMigrateUp

	funcMigrateUpSafe          func(repo repo.MigrationRepo, m *Migration) (err error)
	inspectFuncMigrateUpSafe   func(repo repo.MigrationRepo, m *Migration)
	afterMigrateUpSafeCounter  uint64
	beforeMigrateUpSafeCounter uint64
	MigrateUpSafeMock          mRunnerInterfaceMockMigrateUpSafe
}

// NewRunnerInterfaceMock returns a mock for RunnerInterface
func NewRunnerInterfaceMock(t minimock.Tester) *RunnerInterfaceMock {
	m := &RunnerInterfaceMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.MigrateDownMock = mRunnerInterfaceMockMigrateDown{mock: m}
	m.MigrateDownMock.callArgs = []*RunnerInterfaceMockMigrateDownParams{}

	m.MigrateDownSafeMock = mRunnerInterfaceMockMigrateDownSafe{mock: m}
	m.MigrateDownSafeMock.callArgs = []*RunnerInterfaceMockMigrateDownSafeParams{}

	m.MigrateUpMock = mRunnerInterfaceMockMigrateUp{mock: m}
	m.MigrateUpMock.callArgs = []*RunnerInterfaceMockMigrateUpParams{}

	m.MigrateUpSafeMock = mRunnerInterfaceMockMigrateUpSafe{mock: m}
	m.MigrateUpSafeMock.callArgs = []*RunnerInterfaceMockMigrateUpSafeParams{}

	return m
}

type mRunnerInterfaceMockMigrateDown struct {
	mock               *RunnerInterfaceMock
	defaultExpectation *RunnerInterfaceMockMigrateDownExpectation
	expectations       []*RunnerInterfaceMockMigrateDownExpectation

	callArgs []*RunnerInterfaceMockMigrateDownParams
	mutex    sync.RWMutex
}

// RunnerInterfaceMockMigrateDownExpectation specifies expectation struct of the RunnerInterface.MigrateDown
type RunnerInterfaceMockMigrateDownExpectation struct {
	mock    *RunnerInterfaceMock
	params  *RunnerInterfaceMockMigrateDownParams
	results *RunnerInterfaceMockMigrateDownResults
	Counter uint64
}

// RunnerInterfaceMockMigrateDownParams contains parameters of the RunnerInterface.MigrateDown
type RunnerInterfaceMockMigrateDownParams struct {
	repo repo.MigrationRepo
	m    *Migration
}

// RunnerInterfaceMockMigrateDownResults contains results of the RunnerInterface.MigrateDown
type RunnerInterfaceMockMigrateDownResults struct {
	err error
}

// Expect sets up expected params for RunnerInterface.MigrateDown
func (mmMigrateDown *mRunnerInterfaceMockMigrateDown) Expect(repo repo.MigrationRepo, m *Migration) *mRunnerInterfaceMockMigrateDown {
	if mmMigrateDown.mock.funcMigrateDown != nil {
		mmMigrateDown.mock.t.Fatalf("RunnerInterfaceMock.MigrateDown mock is already set by Set")
	}

	if mmMigrateDown.defaultExpectation == nil {
		mmMigrateDown.defaultExpectation = &RunnerInterfaceMockMigrateDownExpectation{}
	}

	mmMigrateDown.defaultExpectation.params = &RunnerInterfaceMockMigrateDownParams{repo, m}
	for _, e := range mmMigrateDown.expectations {
		if minimock.Equal(e.params, mmMigrateDown.defaultExpectation.params) {
			mmMigrateDown.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMigrateDown.defaultExpectation.params)
		}
	}

	return mmMigrateDown
}

// Inspect accepts an inspector function that has same arguments as the RunnerInterface.MigrateDown
func (mmMigrateDown *mRunnerInterfaceMockMigrateDown) Inspect(f func(repo repo.MigrationRepo, m *Migration)) *mRunnerInterfaceMockMigrateDown {
	if mmMigrateDown.mock.inspectFuncMigrateDown != nil {
		mmMigrateDown.mock.t.Fatalf("Inspect function is already set for RunnerInterfaceMock.MigrateDown")
	}

	mmMigrateDown.mock.inspectFuncMigrateDown = f

	return mmMigrateDown
}

// Return sets up results that will be returned by RunnerInterface.MigrateDown
func (mmMigrateDown *mRunnerInterfaceMockMigrateDown) Return(err error) *RunnerInterfaceMock {
	if mmMigrateDown.mock.funcMigrateDown != nil {
		mmMigrateDown.mock.t.Fatalf("RunnerInterfaceMock.MigrateDown mock is already set by Set")
	}

	if mmMigrateDown.defaultExpectation == nil {
		mmMigrateDown.defaultExpectation = &RunnerInterfaceMockMigrateDownExpectation{mock: mmMigrateDown.mock}
	}
	mmMigrateDown.defaultExpectation.results = &RunnerInterfaceMockMigrateDownResults{err}
	return mmMigrateDown.mock
}

//Set uses given function f to mock the RunnerInterface.MigrateDown method
func (mmMigrateDown *mRunnerInterfaceMockMigrateDown) Set(f func(repo repo.MigrationRepo, m *Migration) (err error)) *RunnerInterfaceMock {
	if mmMigrateDown.defaultExpectation != nil {
		mmMigrateDown.mock.t.Fatalf("Default expectation is already set for the RunnerInterface.MigrateDown method")
	}

	if len(mmMigrateDown.expectations) > 0 {
		mmMigrateDown.mock.t.Fatalf("Some expectations are already set for the RunnerInterface.MigrateDown method")
	}

	mmMigrateDown.mock.funcMigrateDown = f
	return mmMigrateDown.mock
}

// When sets expectation for the RunnerInterface.MigrateDown which will trigger the result defined by the following
// Then helper
func (mmMigrateDown *mRunnerInterfaceMockMigrateDown) When(repo repo.MigrationRepo, m *Migration) *RunnerInterfaceMockMigrateDownExpectation {
	if mmMigrateDown.mock.funcMigrateDown != nil {
		mmMigrateDown.mock.t.Fatalf("RunnerInterfaceMock.MigrateDown mock is already set by Set")
	}

	expectation := &RunnerInterfaceMockMigrateDownExpectation{
		mock:   mmMigrateDown.mock,
		params: &RunnerInterfaceMockMigrateDownParams{repo, m},
	}
	mmMigrateDown.expectations = append(mmMigrateDown.expectations, expectation)
	return expectation
}

// Then sets up RunnerInterface.MigrateDown return parameters for the expectation previously defined by the When method
func (e *RunnerInterfaceMockMigrateDownExpectation) Then(err error) *RunnerInterfaceMock {
	e.results = &RunnerInterfaceMockMigrateDownResults{err}
	return e.mock
}

// MigrateDown implements RunnerInterface
func (mmMigrateDown *RunnerInterfaceMock) MigrateDown(repo repo.MigrationRepo, m *Migration) (err error) {
	mm_atomic.AddUint64(&mmMigrateDown.beforeMigrateDownCounter, 1)
	defer mm_atomic.AddUint64(&mmMigrateDown.afterMigrateDownCounter, 1)

	if mmMigrateDown.inspectFuncMigrateDown != nil {
		mmMigrateDown.inspectFuncMigrateDown(repo, m)
	}

	mm_params := &RunnerInterfaceMockMigrateDownParams{repo, m}

	// Record call args
	mmMigrateDown.MigrateDownMock.mutex.Lock()
	mmMigrateDown.MigrateDownMock.callArgs = append(mmMigrateDown.MigrateDownMock.callArgs, mm_params)
	mmMigrateDown.MigrateDownMock.mutex.Unlock()

	for _, e := range mmMigrateDown.MigrateDownMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMigrateDown.MigrateDownMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMigrateDown.MigrateDownMock.defaultExpectation.Counter, 1)
		mm_want := mmMigrateDown.MigrateDownMock.defaultExpectation.params
		mm_got := RunnerInterfaceMockMigrateDownParams{repo, m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMigrateDown.t.Errorf("RunnerInterfaceMock.MigrateDown got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMigrateDown.MigrateDownMock.defaultExpectation.results
		if mm_results == nil {
			mmMigrateDown.t.Fatal("No results are set for the RunnerInterfaceMock.MigrateDown")
		}
		return (*mm_results).err
	}
	if mmMigrateDown.funcMigrateDown != nil {
		return mmMigrateDown.funcMigrateDown(repo, m)
	}
	mmMigrateDown.t.Fatalf("Unexpected call to RunnerInterfaceMock.MigrateDown. %v %v", repo, m)
	return
}

// MigrateDownAfterCounter returns a count of finished RunnerInterfaceMock.MigrateDown invocations
func (mmMigrateDown *RunnerInterfaceMock) MigrateDownAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrateDown.afterMigrateDownCounter)
}

// MigrateDownBeforeCounter returns a count of RunnerInterfaceMock.MigrateDown invocations
func (mmMigrateDown *RunnerInterfaceMock) MigrateDownBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrateDown.beforeMigrateDownCounter)
}

// Calls returns a list of arguments used in each call to RunnerInterfaceMock.MigrateDown.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMigrateDown *mRunnerInterfaceMockMigrateDown) Calls() []*RunnerInterfaceMockMigrateDownParams {
	mmMigrateDown.mutex.RLock()

	argCopy := make([]*RunnerInterfaceMockMigrateDownParams, len(mmMigrateDown.callArgs))
	copy(argCopy, mmMigrateDown.callArgs)

	mmMigrateDown.mutex.RUnlock()

	return argCopy
}

// MinimockMigrateDownDone returns true if the count of the MigrateDown invocations corresponds
// the number of defined expectations
func (m *RunnerInterfaceMock) MinimockMigrateDownDone() bool {
	for _, e := range m.MigrateDownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateDownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateDownCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrateDown != nil && mm_atomic.LoadUint64(&m.afterMigrateDownCounter) < 1 {
		return false
	}
	return true
}

// MinimockMigrateDownInspect logs each unmet expectation
func (m *RunnerInterfaceMock) MinimockMigrateDownInspect() {
	for _, e := range m.MigrateDownMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RunnerInterfaceMock.MigrateDown with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateDownMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateDownCounter) < 1 {
		if m.MigrateDownMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RunnerInterfaceMock.MigrateDown")
		} else {
			m.t.Errorf("Expected call to RunnerInterfaceMock.MigrateDown with params: %#v", *m.MigrateDownMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrateDown != nil && mm_atomic.LoadUint64(&m.afterMigrateDownCounter) < 1 {
		m.t.Error("Expected call to RunnerInterfaceMock.MigrateDown")
	}
}

type mRunnerInterfaceMockMigrateDownSafe struct {
	mock               *RunnerInterfaceMock
	defaultExpectation *RunnerInterfaceMockMigrateDownSafeExpectation
	expectations       []*RunnerInterfaceMockMigrateDownSafeExpectation

	callArgs []*RunnerInterfaceMockMigrateDownSafeParams
	mutex    sync.RWMutex
}

// RunnerInterfaceMockMigrateDownSafeExpectation specifies expectation struct of the RunnerInterface.MigrateDownSafe
type RunnerInterfaceMockMigrateDownSafeExpectation struct {
	mock    *RunnerInterfaceMock
	params  *RunnerInterfaceMockMigrateDownSafeParams
	results *RunnerInterfaceMockMigrateDownSafeResults
	Counter uint64
}

// RunnerInterfaceMockMigrateDownSafeParams contains parameters of the RunnerInterface.MigrateDownSafe
type RunnerInterfaceMockMigrateDownSafeParams struct {
	repo repo.MigrationRepo
	m    *Migration
}

// RunnerInterfaceMockMigrateDownSafeResults contains results of the RunnerInterface.MigrateDownSafe
type RunnerInterfaceMockMigrateDownSafeResults struct {
	err error
}

// Expect sets up expected params for RunnerInterface.MigrateDownSafe
func (mmMigrateDownSafe *mRunnerInterfaceMockMigrateDownSafe) Expect(repo repo.MigrationRepo, m *Migration) *mRunnerInterfaceMockMigrateDownSafe {
	if mmMigrateDownSafe.mock.funcMigrateDownSafe != nil {
		mmMigrateDownSafe.mock.t.Fatalf("RunnerInterfaceMock.MigrateDownSafe mock is already set by Set")
	}

	if mmMigrateDownSafe.defaultExpectation == nil {
		mmMigrateDownSafe.defaultExpectation = &RunnerInterfaceMockMigrateDownSafeExpectation{}
	}

	mmMigrateDownSafe.defaultExpectation.params = &RunnerInterfaceMockMigrateDownSafeParams{repo, m}
	for _, e := range mmMigrateDownSafe.expectations {
		if minimock.Equal(e.params, mmMigrateDownSafe.defaultExpectation.params) {
			mmMigrateDownSafe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMigrateDownSafe.defaultExpectation.params)
		}
	}

	return mmMigrateDownSafe
}

// Inspect accepts an inspector function that has same arguments as the RunnerInterface.MigrateDownSafe
func (mmMigrateDownSafe *mRunnerInterfaceMockMigrateDownSafe) Inspect(f func(repo repo.MigrationRepo, m *Migration)) *mRunnerInterfaceMockMigrateDownSafe {
	if mmMigrateDownSafe.mock.inspectFuncMigrateDownSafe != nil {
		mmMigrateDownSafe.mock.t.Fatalf("Inspect function is already set for RunnerInterfaceMock.MigrateDownSafe")
	}

	mmMigrateDownSafe.mock.inspectFuncMigrateDownSafe = f

	return mmMigrateDownSafe
}

// Return sets up results that will be returned by RunnerInterface.MigrateDownSafe
func (mmMigrateDownSafe *mRunnerInterfaceMockMigrateDownSafe) Return(err error) *RunnerInterfaceMock {
	if mmMigrateDownSafe.mock.funcMigrateDownSafe != nil {
		mmMigrateDownSafe.mock.t.Fatalf("RunnerInterfaceMock.MigrateDownSafe mock is already set by Set")
	}

	if mmMigrateDownSafe.defaultExpectation == nil {
		mmMigrateDownSafe.defaultExpectation = &RunnerInterfaceMockMigrateDownSafeExpectation{mock: mmMigrateDownSafe.mock}
	}
	mmMigrateDownSafe.defaultExpectation.results = &RunnerInterfaceMockMigrateDownSafeResults{err}
	return mmMigrateDownSafe.mock
}

//Set uses given function f to mock the RunnerInterface.MigrateDownSafe method
func (mmMigrateDownSafe *mRunnerInterfaceMockMigrateDownSafe) Set(f func(repo repo.MigrationRepo, m *Migration) (err error)) *RunnerInterfaceMock {
	if mmMigrateDownSafe.defaultExpectation != nil {
		mmMigrateDownSafe.mock.t.Fatalf("Default expectation is already set for the RunnerInterface.MigrateDownSafe method")
	}

	if len(mmMigrateDownSafe.expectations) > 0 {
		mmMigrateDownSafe.mock.t.Fatalf("Some expectations are already set for the RunnerInterface.MigrateDownSafe method")
	}

	mmMigrateDownSafe.mock.funcMigrateDownSafe = f
	return mmMigrateDownSafe.mock
}

// When sets expectation for the RunnerInterface.MigrateDownSafe which will trigger the result defined by the following
// Then helper
func (mmMigrateDownSafe *mRunnerInterfaceMockMigrateDownSafe) When(repo repo.MigrationRepo, m *Migration) *RunnerInterfaceMockMigrateDownSafeExpectation {
	if mmMigrateDownSafe.mock.funcMigrateDownSafe != nil {
		mmMigrateDownSafe.mock.t.Fatalf("RunnerInterfaceMock.MigrateDownSafe mock is already set by Set")
	}

	expectation := &RunnerInterfaceMockMigrateDownSafeExpectation{
		mock:   mmMigrateDownSafe.mock,
		params: &RunnerInterfaceMockMigrateDownSafeParams{repo, m},
	}
	mmMigrateDownSafe.expectations = append(mmMigrateDownSafe.expectations, expectation)
	return expectation
}

// Then sets up RunnerInterface.MigrateDownSafe return parameters for the expectation previously defined by the When method
func (e *RunnerInterfaceMockMigrateDownSafeExpectation) Then(err error) *RunnerInterfaceMock {
	e.results = &RunnerInterfaceMockMigrateDownSafeResults{err}
	return e.mock
}

// MigrateDownSafe implements RunnerInterface
func (mmMigrateDownSafe *RunnerInterfaceMock) MigrateDownSafe(repo repo.MigrationRepo, m *Migration) (err error) {
	mm_atomic.AddUint64(&mmMigrateDownSafe.beforeMigrateDownSafeCounter, 1)
	defer mm_atomic.AddUint64(&mmMigrateDownSafe.afterMigrateDownSafeCounter, 1)

	if mmMigrateDownSafe.inspectFuncMigrateDownSafe != nil {
		mmMigrateDownSafe.inspectFuncMigrateDownSafe(repo, m)
	}

	mm_params := &RunnerInterfaceMockMigrateDownSafeParams{repo, m}

	// Record call args
	mmMigrateDownSafe.MigrateDownSafeMock.mutex.Lock()
	mmMigrateDownSafe.MigrateDownSafeMock.callArgs = append(mmMigrateDownSafe.MigrateDownSafeMock.callArgs, mm_params)
	mmMigrateDownSafe.MigrateDownSafeMock.mutex.Unlock()

	for _, e := range mmMigrateDownSafe.MigrateDownSafeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMigrateDownSafe.MigrateDownSafeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMigrateDownSafe.MigrateDownSafeMock.defaultExpectation.Counter, 1)
		mm_want := mmMigrateDownSafe.MigrateDownSafeMock.defaultExpectation.params
		mm_got := RunnerInterfaceMockMigrateDownSafeParams{repo, m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMigrateDownSafe.t.Errorf("RunnerInterfaceMock.MigrateDownSafe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMigrateDownSafe.MigrateDownSafeMock.defaultExpectation.results
		if mm_results == nil {
			mmMigrateDownSafe.t.Fatal("No results are set for the RunnerInterfaceMock.MigrateDownSafe")
		}
		return (*mm_results).err
	}
	if mmMigrateDownSafe.funcMigrateDownSafe != nil {
		return mmMigrateDownSafe.funcMigrateDownSafe(repo, m)
	}
	mmMigrateDownSafe.t.Fatalf("Unexpected call to RunnerInterfaceMock.MigrateDownSafe. %v %v", repo, m)
	return
}

// MigrateDownSafeAfterCounter returns a count of finished RunnerInterfaceMock.MigrateDownSafe invocations
func (mmMigrateDownSafe *RunnerInterfaceMock) MigrateDownSafeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrateDownSafe.afterMigrateDownSafeCounter)
}

// MigrateDownSafeBeforeCounter returns a count of RunnerInterfaceMock.MigrateDownSafe invocations
func (mmMigrateDownSafe *RunnerInterfaceMock) MigrateDownSafeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrateDownSafe.beforeMigrateDownSafeCounter)
}

// Calls returns a list of arguments used in each call to RunnerInterfaceMock.MigrateDownSafe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMigrateDownSafe *mRunnerInterfaceMockMigrateDownSafe) Calls() []*RunnerInterfaceMockMigrateDownSafeParams {
	mmMigrateDownSafe.mutex.RLock()

	argCopy := make([]*RunnerInterfaceMockMigrateDownSafeParams, len(mmMigrateDownSafe.callArgs))
	copy(argCopy, mmMigrateDownSafe.callArgs)

	mmMigrateDownSafe.mutex.RUnlock()

	return argCopy
}

// MinimockMigrateDownSafeDone returns true if the count of the MigrateDownSafe invocations corresponds
// the number of defined expectations
func (m *RunnerInterfaceMock) MinimockMigrateDownSafeDone() bool {
	for _, e := range m.MigrateDownSafeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateDownSafeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateDownSafeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrateDownSafe != nil && mm_atomic.LoadUint64(&m.afterMigrateDownSafeCounter) < 1 {
		return false
	}
	return true
}

// MinimockMigrateDownSafeInspect logs each unmet expectation
func (m *RunnerInterfaceMock) MinimockMigrateDownSafeInspect() {
	for _, e := range m.MigrateDownSafeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RunnerInterfaceMock.MigrateDownSafe with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateDownSafeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateDownSafeCounter) < 1 {
		if m.MigrateDownSafeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RunnerInterfaceMock.MigrateDownSafe")
		} else {
			m.t.Errorf("Expected call to RunnerInterfaceMock.MigrateDownSafe with params: %#v", *m.MigrateDownSafeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrateDownSafe != nil && mm_atomic.LoadUint64(&m.afterMigrateDownSafeCounter) < 1 {
		m.t.Error("Expected call to RunnerInterfaceMock.MigrateDownSafe")
	}
}

type mRunnerInterfaceMockMigrateUp struct {
	mock               *RunnerInterfaceMock
	defaultExpectation *RunnerInterfaceMockMigrateUpExpectation
	expectations       []*RunnerInterfaceMockMigrateUpExpectation

	callArgs []*RunnerInterfaceMockMigrateUpParams
	mutex    sync.RWMutex
}

// RunnerInterfaceMockMigrateUpExpectation specifies expectation struct of the RunnerInterface.MigrateUp
type RunnerInterfaceMockMigrateUpExpectation struct {
	mock    *RunnerInterfaceMock
	params  *RunnerInterfaceMockMigrateUpParams
	results *RunnerInterfaceMockMigrateUpResults
	Counter uint64
}

// RunnerInterfaceMockMigrateUpParams contains parameters of the RunnerInterface.MigrateUp
type RunnerInterfaceMockMigrateUpParams struct {
	repo repo.MigrationRepo
	m    *Migration
}

// RunnerInterfaceMockMigrateUpResults contains results of the RunnerInterface.MigrateUp
type RunnerInterfaceMockMigrateUpResults struct {
	err error
}

// Expect sets up expected params for RunnerInterface.MigrateUp
func (mmMigrateUp *mRunnerInterfaceMockMigrateUp) Expect(repo repo.MigrationRepo, m *Migration) *mRunnerInterfaceMockMigrateUp {
	if mmMigrateUp.mock.funcMigrateUp != nil {
		mmMigrateUp.mock.t.Fatalf("RunnerInterfaceMock.MigrateUp mock is already set by Set")
	}

	if mmMigrateUp.defaultExpectation == nil {
		mmMigrateUp.defaultExpectation = &RunnerInterfaceMockMigrateUpExpectation{}
	}

	mmMigrateUp.defaultExpectation.params = &RunnerInterfaceMockMigrateUpParams{repo, m}
	for _, e := range mmMigrateUp.expectations {
		if minimock.Equal(e.params, mmMigrateUp.defaultExpectation.params) {
			mmMigrateUp.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMigrateUp.defaultExpectation.params)
		}
	}

	return mmMigrateUp
}

// Inspect accepts an inspector function that has same arguments as the RunnerInterface.MigrateUp
func (mmMigrateUp *mRunnerInterfaceMockMigrateUp) Inspect(f func(repo repo.MigrationRepo, m *Migration)) *mRunnerInterfaceMockMigrateUp {
	if mmMigrateUp.mock.inspectFuncMigrateUp != nil {
		mmMigrateUp.mock.t.Fatalf("Inspect function is already set for RunnerInterfaceMock.MigrateUp")
	}

	mmMigrateUp.mock.inspectFuncMigrateUp = f

	return mmMigrateUp
}

// Return sets up results that will be returned by RunnerInterface.MigrateUp
func (mmMigrateUp *mRunnerInterfaceMockMigrateUp) Return(err error) *RunnerInterfaceMock {
	if mmMigrateUp.mock.funcMigrateUp != nil {
		mmMigrateUp.mock.t.Fatalf("RunnerInterfaceMock.MigrateUp mock is already set by Set")
	}

	if mmMigrateUp.defaultExpectation == nil {
		mmMigrateUp.defaultExpectation = &RunnerInterfaceMockMigrateUpExpectation{mock: mmMigrateUp.mock}
	}
	mmMigrateUp.defaultExpectation.results = &RunnerInterfaceMockMigrateUpResults{err}
	return mmMigrateUp.mock
}

//Set uses given function f to mock the RunnerInterface.MigrateUp method
func (mmMigrateUp *mRunnerInterfaceMockMigrateUp) Set(f func(repo repo.MigrationRepo, m *Migration) (err error)) *RunnerInterfaceMock {
	if mmMigrateUp.defaultExpectation != nil {
		mmMigrateUp.mock.t.Fatalf("Default expectation is already set for the RunnerInterface.MigrateUp method")
	}

	if len(mmMigrateUp.expectations) > 0 {
		mmMigrateUp.mock.t.Fatalf("Some expectations are already set for the RunnerInterface.MigrateUp method")
	}

	mmMigrateUp.mock.funcMigrateUp = f
	return mmMigrateUp.mock
}

// When sets expectation for the RunnerInterface.MigrateUp which will trigger the result defined by the following
// Then helper
func (mmMigrateUp *mRunnerInterfaceMockMigrateUp) When(repo repo.MigrationRepo, m *Migration) *RunnerInterfaceMockMigrateUpExpectation {
	if mmMigrateUp.mock.funcMigrateUp != nil {
		mmMigrateUp.mock.t.Fatalf("RunnerInterfaceMock.MigrateUp mock is already set by Set")
	}

	expectation := &RunnerInterfaceMockMigrateUpExpectation{
		mock:   mmMigrateUp.mock,
		params: &RunnerInterfaceMockMigrateUpParams{repo, m},
	}
	mmMigrateUp.expectations = append(mmMigrateUp.expectations, expectation)
	return expectation
}

// Then sets up RunnerInterface.MigrateUp return parameters for the expectation previously defined by the When method
func (e *RunnerInterfaceMockMigrateUpExpectation) Then(err error) *RunnerInterfaceMock {
	e.results = &RunnerInterfaceMockMigrateUpResults{err}
	return e.mock
}

// MigrateUp implements RunnerInterface
func (mmMigrateUp *RunnerInterfaceMock) MigrateUp(repo repo.MigrationRepo, m *Migration) (err error) {
	mm_atomic.AddUint64(&mmMigrateUp.beforeMigrateUpCounter, 1)
	defer mm_atomic.AddUint64(&mmMigrateUp.afterMigrateUpCounter, 1)

	if mmMigrateUp.inspectFuncMigrateUp != nil {
		mmMigrateUp.inspectFuncMigrateUp(repo, m)
	}

	mm_params := &RunnerInterfaceMockMigrateUpParams{repo, m}

	// Record call args
	mmMigrateUp.MigrateUpMock.mutex.Lock()
	mmMigrateUp.MigrateUpMock.callArgs = append(mmMigrateUp.MigrateUpMock.callArgs, mm_params)
	mmMigrateUp.MigrateUpMock.mutex.Unlock()

	for _, e := range mmMigrateUp.MigrateUpMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMigrateUp.MigrateUpMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMigrateUp.MigrateUpMock.defaultExpectation.Counter, 1)
		mm_want := mmMigrateUp.MigrateUpMock.defaultExpectation.params
		mm_got := RunnerInterfaceMockMigrateUpParams{repo, m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMigrateUp.t.Errorf("RunnerInterfaceMock.MigrateUp got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMigrateUp.MigrateUpMock.defaultExpectation.results
		if mm_results == nil {
			mmMigrateUp.t.Fatal("No results are set for the RunnerInterfaceMock.MigrateUp")
		}
		return (*mm_results).err
	}
	if mmMigrateUp.funcMigrateUp != nil {
		return mmMigrateUp.funcMigrateUp(repo, m)
	}
	mmMigrateUp.t.Fatalf("Unexpected call to RunnerInterfaceMock.MigrateUp. %v %v", repo, m)
	return
}

// MigrateUpAfterCounter returns a count of finished RunnerInterfaceMock.MigrateUp invocations
func (mmMigrateUp *RunnerInterfaceMock) MigrateUpAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrateUp.afterMigrateUpCounter)
}

// MigrateUpBeforeCounter returns a count of RunnerInterfaceMock.MigrateUp invocations
func (mmMigrateUp *RunnerInterfaceMock) MigrateUpBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrateUp.beforeMigrateUpCounter)
}

// Calls returns a list of arguments used in each call to RunnerInterfaceMock.MigrateUp.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMigrateUp *mRunnerInterfaceMockMigrateUp) Calls() []*RunnerInterfaceMockMigrateUpParams {
	mmMigrateUp.mutex.RLock()

	argCopy := make([]*RunnerInterfaceMockMigrateUpParams, len(mmMigrateUp.callArgs))
	copy(argCopy, mmMigrateUp.callArgs)

	mmMigrateUp.mutex.RUnlock()

	return argCopy
}

// MinimockMigrateUpDone returns true if the count of the MigrateUp invocations corresponds
// the number of defined expectations
func (m *RunnerInterfaceMock) MinimockMigrateUpDone() bool {
	for _, e := range m.MigrateUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateUpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateUpCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrateUp != nil && mm_atomic.LoadUint64(&m.afterMigrateUpCounter) < 1 {
		return false
	}
	return true
}

// MinimockMigrateUpInspect logs each unmet expectation
func (m *RunnerInterfaceMock) MinimockMigrateUpInspect() {
	for _, e := range m.MigrateUpMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RunnerInterfaceMock.MigrateUp with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateUpMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateUpCounter) < 1 {
		if m.MigrateUpMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RunnerInterfaceMock.MigrateUp")
		} else {
			m.t.Errorf("Expected call to RunnerInterfaceMock.MigrateUp with params: %#v", *m.MigrateUpMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrateUp != nil && mm_atomic.LoadUint64(&m.afterMigrateUpCounter) < 1 {
		m.t.Error("Expected call to RunnerInterfaceMock.MigrateUp")
	}
}

type mRunnerInterfaceMockMigrateUpSafe struct {
	mock               *RunnerInterfaceMock
	defaultExpectation *RunnerInterfaceMockMigrateUpSafeExpectation
	expectations       []*RunnerInterfaceMockMigrateUpSafeExpectation

	callArgs []*RunnerInterfaceMockMigrateUpSafeParams
	mutex    sync.RWMutex
}

// RunnerInterfaceMockMigrateUpSafeExpectation specifies expectation struct of the RunnerInterface.MigrateUpSafe
type RunnerInterfaceMockMigrateUpSafeExpectation struct {
	mock    *RunnerInterfaceMock
	params  *RunnerInterfaceMockMigrateUpSafeParams
	results *RunnerInterfaceMockMigrateUpSafeResults
	Counter uint64
}

// RunnerInterfaceMockMigrateUpSafeParams contains parameters of the RunnerInterface.MigrateUpSafe
type RunnerInterfaceMockMigrateUpSafeParams struct {
	repo repo.MigrationRepo
	m    *Migration
}

// RunnerInterfaceMockMigrateUpSafeResults contains results of the RunnerInterface.MigrateUpSafe
type RunnerInterfaceMockMigrateUpSafeResults struct {
	err error
}

// Expect sets up expected params for RunnerInterface.MigrateUpSafe
func (mmMigrateUpSafe *mRunnerInterfaceMockMigrateUpSafe) Expect(repo repo.MigrationRepo, m *Migration) *mRunnerInterfaceMockMigrateUpSafe {
	if mmMigrateUpSafe.mock.funcMigrateUpSafe != nil {
		mmMigrateUpSafe.mock.t.Fatalf("RunnerInterfaceMock.MigrateUpSafe mock is already set by Set")
	}

	if mmMigrateUpSafe.defaultExpectation == nil {
		mmMigrateUpSafe.defaultExpectation = &RunnerInterfaceMockMigrateUpSafeExpectation{}
	}

	mmMigrateUpSafe.defaultExpectation.params = &RunnerInterfaceMockMigrateUpSafeParams{repo, m}
	for _, e := range mmMigrateUpSafe.expectations {
		if minimock.Equal(e.params, mmMigrateUpSafe.defaultExpectation.params) {
			mmMigrateUpSafe.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMigrateUpSafe.defaultExpectation.params)
		}
	}

	return mmMigrateUpSafe
}

// Inspect accepts an inspector function that has same arguments as the RunnerInterface.MigrateUpSafe
func (mmMigrateUpSafe *mRunnerInterfaceMockMigrateUpSafe) Inspect(f func(repo repo.MigrationRepo, m *Migration)) *mRunnerInterfaceMockMigrateUpSafe {
	if mmMigrateUpSafe.mock.inspectFuncMigrateUpSafe != nil {
		mmMigrateUpSafe.mock.t.Fatalf("Inspect function is already set for RunnerInterfaceMock.MigrateUpSafe")
	}

	mmMigrateUpSafe.mock.inspectFuncMigrateUpSafe = f

	return mmMigrateUpSafe
}

// Return sets up results that will be returned by RunnerInterface.MigrateUpSafe
func (mmMigrateUpSafe *mRunnerInterfaceMockMigrateUpSafe) Return(err error) *RunnerInterfaceMock {
	if mmMigrateUpSafe.mock.funcMigrateUpSafe != nil {
		mmMigrateUpSafe.mock.t.Fatalf("RunnerInterfaceMock.MigrateUpSafe mock is already set by Set")
	}

	if mmMigrateUpSafe.defaultExpectation == nil {
		mmMigrateUpSafe.defaultExpectation = &RunnerInterfaceMockMigrateUpSafeExpectation{mock: mmMigrateUpSafe.mock}
	}
	mmMigrateUpSafe.defaultExpectation.results = &RunnerInterfaceMockMigrateUpSafeResults{err}
	return mmMigrateUpSafe.mock
}

//Set uses given function f to mock the RunnerInterface.MigrateUpSafe method
func (mmMigrateUpSafe *mRunnerInterfaceMockMigrateUpSafe) Set(f func(repo repo.MigrationRepo, m *Migration) (err error)) *RunnerInterfaceMock {
	if mmMigrateUpSafe.defaultExpectation != nil {
		mmMigrateUpSafe.mock.t.Fatalf("Default expectation is already set for the RunnerInterface.MigrateUpSafe method")
	}

	if len(mmMigrateUpSafe.expectations) > 0 {
		mmMigrateUpSafe.mock.t.Fatalf("Some expectations are already set for the RunnerInterface.MigrateUpSafe method")
	}

	mmMigrateUpSafe.mock.funcMigrateUpSafe = f
	return mmMigrateUpSafe.mock
}

// When sets expectation for the RunnerInterface.MigrateUpSafe which will trigger the result defined by the following
// Then helper
func (mmMigrateUpSafe *mRunnerInterfaceMockMigrateUpSafe) When(repo repo.MigrationRepo, m *Migration) *RunnerInterfaceMockMigrateUpSafeExpectation {
	if mmMigrateUpSafe.mock.funcMigrateUpSafe != nil {
		mmMigrateUpSafe.mock.t.Fatalf("RunnerInterfaceMock.MigrateUpSafe mock is already set by Set")
	}

	expectation := &RunnerInterfaceMockMigrateUpSafeExpectation{
		mock:   mmMigrateUpSafe.mock,
		params: &RunnerInterfaceMockMigrateUpSafeParams{repo, m},
	}
	mmMigrateUpSafe.expectations = append(mmMigrateUpSafe.expectations, expectation)
	return expectation
}

// Then sets up RunnerInterface.MigrateUpSafe return parameters for the expectation previously defined by the When method
func (e *RunnerInterfaceMockMigrateUpSafeExpectation) Then(err error) *RunnerInterfaceMock {
	e.results = &RunnerInterfaceMockMigrateUpSafeResults{err}
	return e.mock
}

// MigrateUpSafe implements RunnerInterface
func (mmMigrateUpSafe *RunnerInterfaceMock) MigrateUpSafe(repo repo.MigrationRepo, m *Migration) (err error) {
	mm_atomic.AddUint64(&mmMigrateUpSafe.beforeMigrateUpSafeCounter, 1)
	defer mm_atomic.AddUint64(&mmMigrateUpSafe.afterMigrateUpSafeCounter, 1)

	if mmMigrateUpSafe.inspectFuncMigrateUpSafe != nil {
		mmMigrateUpSafe.inspectFuncMigrateUpSafe(repo, m)
	}

	mm_params := &RunnerInterfaceMockMigrateUpSafeParams{repo, m}

	// Record call args
	mmMigrateUpSafe.MigrateUpSafeMock.mutex.Lock()
	mmMigrateUpSafe.MigrateUpSafeMock.callArgs = append(mmMigrateUpSafe.MigrateUpSafeMock.callArgs, mm_params)
	mmMigrateUpSafe.MigrateUpSafeMock.mutex.Unlock()

	for _, e := range mmMigrateUpSafe.MigrateUpSafeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmMigrateUpSafe.MigrateUpSafeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMigrateUpSafe.MigrateUpSafeMock.defaultExpectation.Counter, 1)
		mm_want := mmMigrateUpSafe.MigrateUpSafeMock.defaultExpectation.params
		mm_got := RunnerInterfaceMockMigrateUpSafeParams{repo, m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMigrateUpSafe.t.Errorf("RunnerInterfaceMock.MigrateUpSafe got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMigrateUpSafe.MigrateUpSafeMock.defaultExpectation.results
		if mm_results == nil {
			mmMigrateUpSafe.t.Fatal("No results are set for the RunnerInterfaceMock.MigrateUpSafe")
		}
		return (*mm_results).err
	}
	if mmMigrateUpSafe.funcMigrateUpSafe != nil {
		return mmMigrateUpSafe.funcMigrateUpSafe(repo, m)
	}
	mmMigrateUpSafe.t.Fatalf("Unexpected call to RunnerInterfaceMock.MigrateUpSafe. %v %v", repo, m)
	return
}

// MigrateUpSafeAfterCounter returns a count of finished RunnerInterfaceMock.MigrateUpSafe invocations
func (mmMigrateUpSafe *RunnerInterfaceMock) MigrateUpSafeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrateUpSafe.afterMigrateUpSafeCounter)
}

// MigrateUpSafeBeforeCounter returns a count of RunnerInterfaceMock.MigrateUpSafe invocations
func (mmMigrateUpSafe *RunnerInterfaceMock) MigrateUpSafeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMigrateUpSafe.beforeMigrateUpSafeCounter)
}

// Calls returns a list of arguments used in each call to RunnerInterfaceMock.MigrateUpSafe.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMigrateUpSafe *mRunnerInterfaceMockMigrateUpSafe) Calls() []*RunnerInterfaceMockMigrateUpSafeParams {
	mmMigrateUpSafe.mutex.RLock()

	argCopy := make([]*RunnerInterfaceMockMigrateUpSafeParams, len(mmMigrateUpSafe.callArgs))
	copy(argCopy, mmMigrateUpSafe.callArgs)

	mmMigrateUpSafe.mutex.RUnlock()

	return argCopy
}

// MinimockMigrateUpSafeDone returns true if the count of the MigrateUpSafe invocations corresponds
// the number of defined expectations
func (m *RunnerInterfaceMock) MinimockMigrateUpSafeDone() bool {
	for _, e := range m.MigrateUpSafeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateUpSafeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateUpSafeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrateUpSafe != nil && mm_atomic.LoadUint64(&m.afterMigrateUpSafeCounter) < 1 {
		return false
	}
	return true
}

// MinimockMigrateUpSafeInspect logs each unmet expectation
func (m *RunnerInterfaceMock) MinimockMigrateUpSafeInspect() {
	for _, e := range m.MigrateUpSafeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RunnerInterfaceMock.MigrateUpSafe with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MigrateUpSafeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMigrateUpSafeCounter) < 1 {
		if m.MigrateUpSafeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RunnerInterfaceMock.MigrateUpSafe")
		} else {
			m.t.Errorf("Expected call to RunnerInterfaceMock.MigrateUpSafe with params: %#v", *m.MigrateUpSafeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMigrateUpSafe != nil && mm_atomic.LoadUint64(&m.afterMigrateUpSafeCounter) < 1 {
		m.t.Error("Expected call to RunnerInterfaceMock.MigrateUpSafe")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RunnerInterfaceMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockMigrateDownInspect()

		m.MinimockMigrateDownSafeInspect()

		m.MinimockMigrateUpInspect()

		m.MinimockMigrateUpSafeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RunnerInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RunnerInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockMigrateDownDone() &&
		m.MinimockMigrateDownSafeDone() &&
		m.MinimockMigrateUpDone() &&
		m.MinimockMigrateUpSafeDone()
}
