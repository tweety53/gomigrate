package repo

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"database/sql"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// MigrationRepoMock implements MigrationRepo
type MigrationRepoMock struct {
	t minimock.Tester

	funcCreateVersionTable          func() (err error)
	inspectFuncCreateVersionTable   func()
	afterCreateVersionTableCounter  uint64
	beforeCreateVersionTableCounter uint64
	CreateVersionTableMock          mMigrationRepoMockCreateVersionTable

	funcDeleteVersion          func(v string) (err error)
	inspectFuncDeleteVersion   func(v string)
	afterDeleteVersionCounter  uint64
	beforeDeleteVersionCounter uint64
	DeleteVersionMock          mMigrationRepoMockDeleteVersion

	funcEnsureDBVersion          func() (s1 string, err error)
	inspectFuncEnsureDBVersion   func()
	afterEnsureDBVersionCounter  uint64
	beforeEnsureDBVersionCounter uint64
	EnsureDBVersionMock          mMigrationRepoMockEnsureDBVersion

	funcGetDB          func() (dp1 *sql.DB, err error)
	inspectFuncGetDB   func()
	afterGetDBCounter  uint64
	beforeGetDBCounter uint64
	GetDBMock          mMigrationRepoMockGetDB

	funcGetDBVersion          func() (s1 string, err error)
	inspectFuncGetDBVersion   func()
	afterGetDBVersionCounter  uint64
	beforeGetDBVersionCounter uint64
	GetDBVersionMock          mMigrationRepoMockGetDBVersion

	funcGetMigrationsHistory          func(limit int) (m1 MigrationRecords, err error)
	inspectFuncGetMigrationsHistory   func(limit int)
	afterGetMigrationsHistoryCounter  uint64
	beforeGetMigrationsHistoryCounter uint64
	GetMigrationsHistoryMock          mMigrationRepoMockGetMigrationsHistory

	funcInsertUnAppliedVersion          func(v string) (err error)
	inspectFuncInsertUnAppliedVersion   func(v string)
	afterInsertUnAppliedVersionCounter  uint64
	beforeInsertUnAppliedVersionCounter uint64
	InsertUnAppliedVersionMock          mMigrationRepoMockInsertUnAppliedVersion

	funcInsertVersion          func(v string) (err error)
	inspectFuncInsertVersion   func(v string)
	afterInsertVersionCounter  uint64
	beforeInsertVersionCounter uint64
	InsertVersionMock          mMigrationRepoMockInsertVersion

	funcLockVersion          func(v string) (err error)
	inspectFuncLockVersion   func(v string)
	afterLockVersionCounter  uint64
	beforeLockVersionCounter uint64
	LockVersionMock          mMigrationRepoMockLockVersion

	funcUpdateApplyTime          func(v string) (err error)
	inspectFuncUpdateApplyTime   func(v string)
	afterUpdateApplyTimeCounter  uint64
	beforeUpdateApplyTimeCounter uint64
	UpdateApplyTimeMock          mMigrationRepoMockUpdateApplyTime
}

// NewMigrationRepoMock returns a mock for MigrationRepo
func NewMigrationRepoMock(t minimock.Tester) *MigrationRepoMock {
	m := &MigrationRepoMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateVersionTableMock = mMigrationRepoMockCreateVersionTable{mock: m}

	m.DeleteVersionMock = mMigrationRepoMockDeleteVersion{mock: m}
	m.DeleteVersionMock.callArgs = []*MigrationRepoMockDeleteVersionParams{}

	m.EnsureDBVersionMock = mMigrationRepoMockEnsureDBVersion{mock: m}

	m.GetDBMock = mMigrationRepoMockGetDB{mock: m}

	m.GetDBVersionMock = mMigrationRepoMockGetDBVersion{mock: m}

	m.GetMigrationsHistoryMock = mMigrationRepoMockGetMigrationsHistory{mock: m}
	m.GetMigrationsHistoryMock.callArgs = []*MigrationRepoMockGetMigrationsHistoryParams{}

	m.InsertUnAppliedVersionMock = mMigrationRepoMockInsertUnAppliedVersion{mock: m}
	m.InsertUnAppliedVersionMock.callArgs = []*MigrationRepoMockInsertUnAppliedVersionParams{}

	m.InsertVersionMock = mMigrationRepoMockInsertVersion{mock: m}
	m.InsertVersionMock.callArgs = []*MigrationRepoMockInsertVersionParams{}

	m.LockVersionMock = mMigrationRepoMockLockVersion{mock: m}
	m.LockVersionMock.callArgs = []*MigrationRepoMockLockVersionParams{}

	m.UpdateApplyTimeMock = mMigrationRepoMockUpdateApplyTime{mock: m}
	m.UpdateApplyTimeMock.callArgs = []*MigrationRepoMockUpdateApplyTimeParams{}

	return m
}

type mMigrationRepoMockCreateVersionTable struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockCreateVersionTableExpectation
	expectations       []*MigrationRepoMockCreateVersionTableExpectation
}

// MigrationRepoMockCreateVersionTableExpectation specifies expectation struct of the MigrationRepo.CreateVersionTable
type MigrationRepoMockCreateVersionTableExpectation struct {
	mock *MigrationRepoMock

	results *MigrationRepoMockCreateVersionTableResults
	Counter uint64
}

// MigrationRepoMockCreateVersionTableResults contains results of the MigrationRepo.CreateVersionTable
type MigrationRepoMockCreateVersionTableResults struct {
	err error
}

// Expect sets up expected params for MigrationRepo.CreateVersionTable
func (mmCreateVersionTable *mMigrationRepoMockCreateVersionTable) Expect() *mMigrationRepoMockCreateVersionTable {
	if mmCreateVersionTable.mock.funcCreateVersionTable != nil {
		mmCreateVersionTable.mock.t.Fatalf("MigrationRepoMock.CreateVersionTable mock is already set by Set")
	}

	if mmCreateVersionTable.defaultExpectation == nil {
		mmCreateVersionTable.defaultExpectation = &MigrationRepoMockCreateVersionTableExpectation{}
	}

	return mmCreateVersionTable
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.CreateVersionTable
func (mmCreateVersionTable *mMigrationRepoMockCreateVersionTable) Inspect(f func()) *mMigrationRepoMockCreateVersionTable {
	if mmCreateVersionTable.mock.inspectFuncCreateVersionTable != nil {
		mmCreateVersionTable.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.CreateVersionTable")
	}

	mmCreateVersionTable.mock.inspectFuncCreateVersionTable = f

	return mmCreateVersionTable
}

// Return sets up results that will be returned by MigrationRepo.CreateVersionTable
func (mmCreateVersionTable *mMigrationRepoMockCreateVersionTable) Return(err error) *MigrationRepoMock {
	if mmCreateVersionTable.mock.funcCreateVersionTable != nil {
		mmCreateVersionTable.mock.t.Fatalf("MigrationRepoMock.CreateVersionTable mock is already set by Set")
	}

	if mmCreateVersionTable.defaultExpectation == nil {
		mmCreateVersionTable.defaultExpectation = &MigrationRepoMockCreateVersionTableExpectation{mock: mmCreateVersionTable.mock}
	}
	mmCreateVersionTable.defaultExpectation.results = &MigrationRepoMockCreateVersionTableResults{err}
	return mmCreateVersionTable.mock
}

//Set uses given function f to mock the MigrationRepo.CreateVersionTable method
func (mmCreateVersionTable *mMigrationRepoMockCreateVersionTable) Set(f func() (err error)) *MigrationRepoMock {
	if mmCreateVersionTable.defaultExpectation != nil {
		mmCreateVersionTable.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.CreateVersionTable method")
	}

	if len(mmCreateVersionTable.expectations) > 0 {
		mmCreateVersionTable.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.CreateVersionTable method")
	}

	mmCreateVersionTable.mock.funcCreateVersionTable = f
	return mmCreateVersionTable.mock
}

// CreateVersionTable implements MigrationRepo
func (mmCreateVersionTable *MigrationRepoMock) CreateVersionTable() (err error) {
	mm_atomic.AddUint64(&mmCreateVersionTable.beforeCreateVersionTableCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateVersionTable.afterCreateVersionTableCounter, 1)

	if mmCreateVersionTable.inspectFuncCreateVersionTable != nil {
		mmCreateVersionTable.inspectFuncCreateVersionTable()
	}

	if mmCreateVersionTable.CreateVersionTableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateVersionTable.CreateVersionTableMock.defaultExpectation.Counter, 1)

		mm_results := mmCreateVersionTable.CreateVersionTableMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateVersionTable.t.Fatal("No results are set for the MigrationRepoMock.CreateVersionTable")
		}
		return (*mm_results).err
	}
	if mmCreateVersionTable.funcCreateVersionTable != nil {
		return mmCreateVersionTable.funcCreateVersionTable()
	}
	mmCreateVersionTable.t.Fatalf("Unexpected call to MigrationRepoMock.CreateVersionTable.")
	return
}

// CreateVersionTableAfterCounter returns a count of finished MigrationRepoMock.CreateVersionTable invocations
func (mmCreateVersionTable *MigrationRepoMock) CreateVersionTableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateVersionTable.afterCreateVersionTableCounter)
}

// CreateVersionTableBeforeCounter returns a count of MigrationRepoMock.CreateVersionTable invocations
func (mmCreateVersionTable *MigrationRepoMock) CreateVersionTableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateVersionTable.beforeCreateVersionTableCounter)
}

// MinimockCreateVersionTableDone returns true if the count of the CreateVersionTable invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockCreateVersionTableDone() bool {
	for _, e := range m.CreateVersionTableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateVersionTableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateVersionTableCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateVersionTable != nil && mm_atomic.LoadUint64(&m.afterCreateVersionTableCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateVersionTableInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockCreateVersionTableInspect() {
	for _, e := range m.CreateVersionTableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationRepoMock.CreateVersionTable")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateVersionTableMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateVersionTableCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.CreateVersionTable")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateVersionTable != nil && mm_atomic.LoadUint64(&m.afterCreateVersionTableCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.CreateVersionTable")
	}
}

type mMigrationRepoMockDeleteVersion struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockDeleteVersionExpectation
	expectations       []*MigrationRepoMockDeleteVersionExpectation

	callArgs []*MigrationRepoMockDeleteVersionParams
	mutex    sync.RWMutex
}

// MigrationRepoMockDeleteVersionExpectation specifies expectation struct of the MigrationRepo.DeleteVersion
type MigrationRepoMockDeleteVersionExpectation struct {
	mock    *MigrationRepoMock
	params  *MigrationRepoMockDeleteVersionParams
	results *MigrationRepoMockDeleteVersionResults
	Counter uint64
}

// MigrationRepoMockDeleteVersionParams contains parameters of the MigrationRepo.DeleteVersion
type MigrationRepoMockDeleteVersionParams struct {
	v string
}

// MigrationRepoMockDeleteVersionResults contains results of the MigrationRepo.DeleteVersion
type MigrationRepoMockDeleteVersionResults struct {
	err error
}

// Expect sets up expected params for MigrationRepo.DeleteVersion
func (mmDeleteVersion *mMigrationRepoMockDeleteVersion) Expect(v string) *mMigrationRepoMockDeleteVersion {
	if mmDeleteVersion.mock.funcDeleteVersion != nil {
		mmDeleteVersion.mock.t.Fatalf("MigrationRepoMock.DeleteVersion mock is already set by Set")
	}

	if mmDeleteVersion.defaultExpectation == nil {
		mmDeleteVersion.defaultExpectation = &MigrationRepoMockDeleteVersionExpectation{}
	}

	mmDeleteVersion.defaultExpectation.params = &MigrationRepoMockDeleteVersionParams{v}
	for _, e := range mmDeleteVersion.expectations {
		if minimock.Equal(e.params, mmDeleteVersion.defaultExpectation.params) {
			mmDeleteVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteVersion.defaultExpectation.params)
		}
	}

	return mmDeleteVersion
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.DeleteVersion
func (mmDeleteVersion *mMigrationRepoMockDeleteVersion) Inspect(f func(v string)) *mMigrationRepoMockDeleteVersion {
	if mmDeleteVersion.mock.inspectFuncDeleteVersion != nil {
		mmDeleteVersion.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.DeleteVersion")
	}

	mmDeleteVersion.mock.inspectFuncDeleteVersion = f

	return mmDeleteVersion
}

// Return sets up results that will be returned by MigrationRepo.DeleteVersion
func (mmDeleteVersion *mMigrationRepoMockDeleteVersion) Return(err error) *MigrationRepoMock {
	if mmDeleteVersion.mock.funcDeleteVersion != nil {
		mmDeleteVersion.mock.t.Fatalf("MigrationRepoMock.DeleteVersion mock is already set by Set")
	}

	if mmDeleteVersion.defaultExpectation == nil {
		mmDeleteVersion.defaultExpectation = &MigrationRepoMockDeleteVersionExpectation{mock: mmDeleteVersion.mock}
	}
	mmDeleteVersion.defaultExpectation.results = &MigrationRepoMockDeleteVersionResults{err}
	return mmDeleteVersion.mock
}

//Set uses given function f to mock the MigrationRepo.DeleteVersion method
func (mmDeleteVersion *mMigrationRepoMockDeleteVersion) Set(f func(v string) (err error)) *MigrationRepoMock {
	if mmDeleteVersion.defaultExpectation != nil {
		mmDeleteVersion.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.DeleteVersion method")
	}

	if len(mmDeleteVersion.expectations) > 0 {
		mmDeleteVersion.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.DeleteVersion method")
	}

	mmDeleteVersion.mock.funcDeleteVersion = f
	return mmDeleteVersion.mock
}

// When sets expectation for the MigrationRepo.DeleteVersion which will trigger the result defined by the following
// Then helper
func (mmDeleteVersion *mMigrationRepoMockDeleteVersion) When(v string) *MigrationRepoMockDeleteVersionExpectation {
	if mmDeleteVersion.mock.funcDeleteVersion != nil {
		mmDeleteVersion.mock.t.Fatalf("MigrationRepoMock.DeleteVersion mock is already set by Set")
	}

	expectation := &MigrationRepoMockDeleteVersionExpectation{
		mock:   mmDeleteVersion.mock,
		params: &MigrationRepoMockDeleteVersionParams{v},
	}
	mmDeleteVersion.expectations = append(mmDeleteVersion.expectations, expectation)
	return expectation
}

// Then sets up MigrationRepo.DeleteVersion return parameters for the expectation previously defined by the When method
func (e *MigrationRepoMockDeleteVersionExpectation) Then(err error) *MigrationRepoMock {
	e.results = &MigrationRepoMockDeleteVersionResults{err}
	return e.mock
}

// DeleteVersion implements MigrationRepo
func (mmDeleteVersion *MigrationRepoMock) DeleteVersion(v string) (err error) {
	mm_atomic.AddUint64(&mmDeleteVersion.beforeDeleteVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteVersion.afterDeleteVersionCounter, 1)

	if mmDeleteVersion.inspectFuncDeleteVersion != nil {
		mmDeleteVersion.inspectFuncDeleteVersion(v)
	}

	mm_params := &MigrationRepoMockDeleteVersionParams{v}

	// Record call args
	mmDeleteVersion.DeleteVersionMock.mutex.Lock()
	mmDeleteVersion.DeleteVersionMock.callArgs = append(mmDeleteVersion.DeleteVersionMock.callArgs, mm_params)
	mmDeleteVersion.DeleteVersionMock.mutex.Unlock()

	for _, e := range mmDeleteVersion.DeleteVersionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteVersion.DeleteVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteVersion.DeleteVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteVersion.DeleteVersionMock.defaultExpectation.params
		mm_got := MigrationRepoMockDeleteVersionParams{v}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteVersion.t.Errorf("MigrationRepoMock.DeleteVersion got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteVersion.DeleteVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteVersion.t.Fatal("No results are set for the MigrationRepoMock.DeleteVersion")
		}
		return (*mm_results).err
	}
	if mmDeleteVersion.funcDeleteVersion != nil {
		return mmDeleteVersion.funcDeleteVersion(v)
	}
	mmDeleteVersion.t.Fatalf("Unexpected call to MigrationRepoMock.DeleteVersion. %v", v)
	return
}

// DeleteVersionAfterCounter returns a count of finished MigrationRepoMock.DeleteVersion invocations
func (mmDeleteVersion *MigrationRepoMock) DeleteVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteVersion.afterDeleteVersionCounter)
}

// DeleteVersionBeforeCounter returns a count of MigrationRepoMock.DeleteVersion invocations
func (mmDeleteVersion *MigrationRepoMock) DeleteVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteVersion.beforeDeleteVersionCounter)
}

// Calls returns a list of arguments used in each call to MigrationRepoMock.DeleteVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteVersion *mMigrationRepoMockDeleteVersion) Calls() []*MigrationRepoMockDeleteVersionParams {
	mmDeleteVersion.mutex.RLock()

	argCopy := make([]*MigrationRepoMockDeleteVersionParams, len(mmDeleteVersion.callArgs))
	copy(argCopy, mmDeleteVersion.callArgs)

	mmDeleteVersion.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteVersionDone returns true if the count of the DeleteVersion invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockDeleteVersionDone() bool {
	for _, e := range m.DeleteVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteVersionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteVersion != nil && mm_atomic.LoadUint64(&m.afterDeleteVersionCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteVersionInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockDeleteVersionInspect() {
	for _, e := range m.DeleteVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationRepoMock.DeleteVersion with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteVersionCounter) < 1 {
		if m.DeleteVersionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationRepoMock.DeleteVersion")
		} else {
			m.t.Errorf("Expected call to MigrationRepoMock.DeleteVersion with params: %#v", *m.DeleteVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteVersion != nil && mm_atomic.LoadUint64(&m.afterDeleteVersionCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.DeleteVersion")
	}
}

type mMigrationRepoMockEnsureDBVersion struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockEnsureDBVersionExpectation
	expectations       []*MigrationRepoMockEnsureDBVersionExpectation
}

// MigrationRepoMockEnsureDBVersionExpectation specifies expectation struct of the MigrationRepo.EnsureDBVersion
type MigrationRepoMockEnsureDBVersionExpectation struct {
	mock *MigrationRepoMock

	results *MigrationRepoMockEnsureDBVersionResults
	Counter uint64
}

// MigrationRepoMockEnsureDBVersionResults contains results of the MigrationRepo.EnsureDBVersion
type MigrationRepoMockEnsureDBVersionResults struct {
	s1  string
	err error
}

// Expect sets up expected params for MigrationRepo.EnsureDBVersion
func (mmEnsureDBVersion *mMigrationRepoMockEnsureDBVersion) Expect() *mMigrationRepoMockEnsureDBVersion {
	if mmEnsureDBVersion.mock.funcEnsureDBVersion != nil {
		mmEnsureDBVersion.mock.t.Fatalf("MigrationRepoMock.EnsureDBVersion mock is already set by Set")
	}

	if mmEnsureDBVersion.defaultExpectation == nil {
		mmEnsureDBVersion.defaultExpectation = &MigrationRepoMockEnsureDBVersionExpectation{}
	}

	return mmEnsureDBVersion
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.EnsureDBVersion
func (mmEnsureDBVersion *mMigrationRepoMockEnsureDBVersion) Inspect(f func()) *mMigrationRepoMockEnsureDBVersion {
	if mmEnsureDBVersion.mock.inspectFuncEnsureDBVersion != nil {
		mmEnsureDBVersion.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.EnsureDBVersion")
	}

	mmEnsureDBVersion.mock.inspectFuncEnsureDBVersion = f

	return mmEnsureDBVersion
}

// Return sets up results that will be returned by MigrationRepo.EnsureDBVersion
func (mmEnsureDBVersion *mMigrationRepoMockEnsureDBVersion) Return(s1 string, err error) *MigrationRepoMock {
	if mmEnsureDBVersion.mock.funcEnsureDBVersion != nil {
		mmEnsureDBVersion.mock.t.Fatalf("MigrationRepoMock.EnsureDBVersion mock is already set by Set")
	}

	if mmEnsureDBVersion.defaultExpectation == nil {
		mmEnsureDBVersion.defaultExpectation = &MigrationRepoMockEnsureDBVersionExpectation{mock: mmEnsureDBVersion.mock}
	}
	mmEnsureDBVersion.defaultExpectation.results = &MigrationRepoMockEnsureDBVersionResults{s1, err}
	return mmEnsureDBVersion.mock
}

//Set uses given function f to mock the MigrationRepo.EnsureDBVersion method
func (mmEnsureDBVersion *mMigrationRepoMockEnsureDBVersion) Set(f func() (s1 string, err error)) *MigrationRepoMock {
	if mmEnsureDBVersion.defaultExpectation != nil {
		mmEnsureDBVersion.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.EnsureDBVersion method")
	}

	if len(mmEnsureDBVersion.expectations) > 0 {
		mmEnsureDBVersion.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.EnsureDBVersion method")
	}

	mmEnsureDBVersion.mock.funcEnsureDBVersion = f
	return mmEnsureDBVersion.mock
}

// EnsureDBVersion implements MigrationRepo
func (mmEnsureDBVersion *MigrationRepoMock) EnsureDBVersion() (s1 string, err error) {
	mm_atomic.AddUint64(&mmEnsureDBVersion.beforeEnsureDBVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmEnsureDBVersion.afterEnsureDBVersionCounter, 1)

	if mmEnsureDBVersion.inspectFuncEnsureDBVersion != nil {
		mmEnsureDBVersion.inspectFuncEnsureDBVersion()
	}

	if mmEnsureDBVersion.EnsureDBVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmEnsureDBVersion.EnsureDBVersionMock.defaultExpectation.Counter, 1)

		mm_results := mmEnsureDBVersion.EnsureDBVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmEnsureDBVersion.t.Fatal("No results are set for the MigrationRepoMock.EnsureDBVersion")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmEnsureDBVersion.funcEnsureDBVersion != nil {
		return mmEnsureDBVersion.funcEnsureDBVersion()
	}
	mmEnsureDBVersion.t.Fatalf("Unexpected call to MigrationRepoMock.EnsureDBVersion.")
	return
}

// EnsureDBVersionAfterCounter returns a count of finished MigrationRepoMock.EnsureDBVersion invocations
func (mmEnsureDBVersion *MigrationRepoMock) EnsureDBVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnsureDBVersion.afterEnsureDBVersionCounter)
}

// EnsureDBVersionBeforeCounter returns a count of MigrationRepoMock.EnsureDBVersion invocations
func (mmEnsureDBVersion *MigrationRepoMock) EnsureDBVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmEnsureDBVersion.beforeEnsureDBVersionCounter)
}

// MinimockEnsureDBVersionDone returns true if the count of the EnsureDBVersion invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockEnsureDBVersionDone() bool {
	for _, e := range m.EnsureDBVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnsureDBVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnsureDBVersionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnsureDBVersion != nil && mm_atomic.LoadUint64(&m.afterEnsureDBVersionCounter) < 1 {
		return false
	}
	return true
}

// MinimockEnsureDBVersionInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockEnsureDBVersionInspect() {
	for _, e := range m.EnsureDBVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationRepoMock.EnsureDBVersion")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.EnsureDBVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterEnsureDBVersionCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.EnsureDBVersion")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcEnsureDBVersion != nil && mm_atomic.LoadUint64(&m.afterEnsureDBVersionCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.EnsureDBVersion")
	}
}

type mMigrationRepoMockGetDB struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockGetDBExpectation
	expectations       []*MigrationRepoMockGetDBExpectation
}

// MigrationRepoMockGetDBExpectation specifies expectation struct of the MigrationRepo.GetDB
type MigrationRepoMockGetDBExpectation struct {
	mock *MigrationRepoMock

	results *MigrationRepoMockGetDBResults
	Counter uint64
}

// MigrationRepoMockGetDBResults contains results of the MigrationRepo.GetDB
type MigrationRepoMockGetDBResults struct {
	dp1 *sql.DB
	err error
}

// Expect sets up expected params for MigrationRepo.GetDB
func (mmGetDB *mMigrationRepoMockGetDB) Expect() *mMigrationRepoMockGetDB {
	if mmGetDB.mock.funcGetDB != nil {
		mmGetDB.mock.t.Fatalf("MigrationRepoMock.GetDB mock is already set by Set")
	}

	if mmGetDB.defaultExpectation == nil {
		mmGetDB.defaultExpectation = &MigrationRepoMockGetDBExpectation{}
	}

	return mmGetDB
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.GetDB
func (mmGetDB *mMigrationRepoMockGetDB) Inspect(f func()) *mMigrationRepoMockGetDB {
	if mmGetDB.mock.inspectFuncGetDB != nil {
		mmGetDB.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.GetDB")
	}

	mmGetDB.mock.inspectFuncGetDB = f

	return mmGetDB
}

// Return sets up results that will be returned by MigrationRepo.GetDB
func (mmGetDB *mMigrationRepoMockGetDB) Return(dp1 *sql.DB, err error) *MigrationRepoMock {
	if mmGetDB.mock.funcGetDB != nil {
		mmGetDB.mock.t.Fatalf("MigrationRepoMock.GetDB mock is already set by Set")
	}

	if mmGetDB.defaultExpectation == nil {
		mmGetDB.defaultExpectation = &MigrationRepoMockGetDBExpectation{mock: mmGetDB.mock}
	}
	mmGetDB.defaultExpectation.results = &MigrationRepoMockGetDBResults{dp1, err}
	return mmGetDB.mock
}

//Set uses given function f to mock the MigrationRepo.GetDB method
func (mmGetDB *mMigrationRepoMockGetDB) Set(f func() (dp1 *sql.DB, err error)) *MigrationRepoMock {
	if mmGetDB.defaultExpectation != nil {
		mmGetDB.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.GetDB method")
	}

	if len(mmGetDB.expectations) > 0 {
		mmGetDB.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.GetDB method")
	}

	mmGetDB.mock.funcGetDB = f
	return mmGetDB.mock
}

// GetDB implements MigrationRepo
func (mmGetDB *MigrationRepoMock) GetDB() (dp1 *sql.DB, err error) {
	mm_atomic.AddUint64(&mmGetDB.beforeGetDBCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDB.afterGetDBCounter, 1)

	if mmGetDB.inspectFuncGetDB != nil {
		mmGetDB.inspectFuncGetDB()
	}

	if mmGetDB.GetDBMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDB.GetDBMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDB.GetDBMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDB.t.Fatal("No results are set for the MigrationRepoMock.GetDB")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmGetDB.funcGetDB != nil {
		return mmGetDB.funcGetDB()
	}
	mmGetDB.t.Fatalf("Unexpected call to MigrationRepoMock.GetDB.")
	return
}

// GetDBAfterCounter returns a count of finished MigrationRepoMock.GetDB invocations
func (mmGetDB *MigrationRepoMock) GetDBAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDB.afterGetDBCounter)
}

// GetDBBeforeCounter returns a count of MigrationRepoMock.GetDB invocations
func (mmGetDB *MigrationRepoMock) GetDBBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDB.beforeGetDBCounter)
}

// MinimockGetDBDone returns true if the count of the GetDB invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockGetDBDone() bool {
	for _, e := range m.GetDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDBMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDBCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDB != nil && mm_atomic.LoadUint64(&m.afterGetDBCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDBInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockGetDBInspect() {
	for _, e := range m.GetDBMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationRepoMock.GetDB")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDBMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDBCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.GetDB")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDB != nil && mm_atomic.LoadUint64(&m.afterGetDBCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.GetDB")
	}
}

type mMigrationRepoMockGetDBVersion struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockGetDBVersionExpectation
	expectations       []*MigrationRepoMockGetDBVersionExpectation
}

// MigrationRepoMockGetDBVersionExpectation specifies expectation struct of the MigrationRepo.GetDBVersion
type MigrationRepoMockGetDBVersionExpectation struct {
	mock *MigrationRepoMock

	results *MigrationRepoMockGetDBVersionResults
	Counter uint64
}

// MigrationRepoMockGetDBVersionResults contains results of the MigrationRepo.GetDBVersion
type MigrationRepoMockGetDBVersionResults struct {
	s1  string
	err error
}

// Expect sets up expected params for MigrationRepo.GetDBVersion
func (mmGetDBVersion *mMigrationRepoMockGetDBVersion) Expect() *mMigrationRepoMockGetDBVersion {
	if mmGetDBVersion.mock.funcGetDBVersion != nil {
		mmGetDBVersion.mock.t.Fatalf("MigrationRepoMock.GetDBVersion mock is already set by Set")
	}

	if mmGetDBVersion.defaultExpectation == nil {
		mmGetDBVersion.defaultExpectation = &MigrationRepoMockGetDBVersionExpectation{}
	}

	return mmGetDBVersion
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.GetDBVersion
func (mmGetDBVersion *mMigrationRepoMockGetDBVersion) Inspect(f func()) *mMigrationRepoMockGetDBVersion {
	if mmGetDBVersion.mock.inspectFuncGetDBVersion != nil {
		mmGetDBVersion.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.GetDBVersion")
	}

	mmGetDBVersion.mock.inspectFuncGetDBVersion = f

	return mmGetDBVersion
}

// Return sets up results that will be returned by MigrationRepo.GetDBVersion
func (mmGetDBVersion *mMigrationRepoMockGetDBVersion) Return(s1 string, err error) *MigrationRepoMock {
	if mmGetDBVersion.mock.funcGetDBVersion != nil {
		mmGetDBVersion.mock.t.Fatalf("MigrationRepoMock.GetDBVersion mock is already set by Set")
	}

	if mmGetDBVersion.defaultExpectation == nil {
		mmGetDBVersion.defaultExpectation = &MigrationRepoMockGetDBVersionExpectation{mock: mmGetDBVersion.mock}
	}
	mmGetDBVersion.defaultExpectation.results = &MigrationRepoMockGetDBVersionResults{s1, err}
	return mmGetDBVersion.mock
}

//Set uses given function f to mock the MigrationRepo.GetDBVersion method
func (mmGetDBVersion *mMigrationRepoMockGetDBVersion) Set(f func() (s1 string, err error)) *MigrationRepoMock {
	if mmGetDBVersion.defaultExpectation != nil {
		mmGetDBVersion.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.GetDBVersion method")
	}

	if len(mmGetDBVersion.expectations) > 0 {
		mmGetDBVersion.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.GetDBVersion method")
	}

	mmGetDBVersion.mock.funcGetDBVersion = f
	return mmGetDBVersion.mock
}

// GetDBVersion implements MigrationRepo
func (mmGetDBVersion *MigrationRepoMock) GetDBVersion() (s1 string, err error) {
	mm_atomic.AddUint64(&mmGetDBVersion.beforeGetDBVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetDBVersion.afterGetDBVersionCounter, 1)

	if mmGetDBVersion.inspectFuncGetDBVersion != nil {
		mmGetDBVersion.inspectFuncGetDBVersion()
	}

	if mmGetDBVersion.GetDBVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetDBVersion.GetDBVersionMock.defaultExpectation.Counter, 1)

		mm_results := mmGetDBVersion.GetDBVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetDBVersion.t.Fatal("No results are set for the MigrationRepoMock.GetDBVersion")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmGetDBVersion.funcGetDBVersion != nil {
		return mmGetDBVersion.funcGetDBVersion()
	}
	mmGetDBVersion.t.Fatalf("Unexpected call to MigrationRepoMock.GetDBVersion.")
	return
}

// GetDBVersionAfterCounter returns a count of finished MigrationRepoMock.GetDBVersion invocations
func (mmGetDBVersion *MigrationRepoMock) GetDBVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDBVersion.afterGetDBVersionCounter)
}

// GetDBVersionBeforeCounter returns a count of MigrationRepoMock.GetDBVersion invocations
func (mmGetDBVersion *MigrationRepoMock) GetDBVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetDBVersion.beforeGetDBVersionCounter)
}

// MinimockGetDBVersionDone returns true if the count of the GetDBVersion invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockGetDBVersionDone() bool {
	for _, e := range m.GetDBVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDBVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDBVersionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDBVersion != nil && mm_atomic.LoadUint64(&m.afterGetDBVersionCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetDBVersionInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockGetDBVersionInspect() {
	for _, e := range m.GetDBVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MigrationRepoMock.GetDBVersion")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetDBVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetDBVersionCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.GetDBVersion")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetDBVersion != nil && mm_atomic.LoadUint64(&m.afterGetDBVersionCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.GetDBVersion")
	}
}

type mMigrationRepoMockGetMigrationsHistory struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockGetMigrationsHistoryExpectation
	expectations       []*MigrationRepoMockGetMigrationsHistoryExpectation

	callArgs []*MigrationRepoMockGetMigrationsHistoryParams
	mutex    sync.RWMutex
}

// MigrationRepoMockGetMigrationsHistoryExpectation specifies expectation struct of the MigrationRepo.GetMigrationsHistory
type MigrationRepoMockGetMigrationsHistoryExpectation struct {
	mock    *MigrationRepoMock
	params  *MigrationRepoMockGetMigrationsHistoryParams
	results *MigrationRepoMockGetMigrationsHistoryResults
	Counter uint64
}

// MigrationRepoMockGetMigrationsHistoryParams contains parameters of the MigrationRepo.GetMigrationsHistory
type MigrationRepoMockGetMigrationsHistoryParams struct {
	limit int
}

// MigrationRepoMockGetMigrationsHistoryResults contains results of the MigrationRepo.GetMigrationsHistory
type MigrationRepoMockGetMigrationsHistoryResults struct {
	m1  MigrationRecords
	err error
}

// Expect sets up expected params for MigrationRepo.GetMigrationsHistory
func (mmGetMigrationsHistory *mMigrationRepoMockGetMigrationsHistory) Expect(limit int) *mMigrationRepoMockGetMigrationsHistory {
	if mmGetMigrationsHistory.mock.funcGetMigrationsHistory != nil {
		mmGetMigrationsHistory.mock.t.Fatalf("MigrationRepoMock.GetMigrationsHistory mock is already set by Set")
	}

	if mmGetMigrationsHistory.defaultExpectation == nil {
		mmGetMigrationsHistory.defaultExpectation = &MigrationRepoMockGetMigrationsHistoryExpectation{}
	}

	mmGetMigrationsHistory.defaultExpectation.params = &MigrationRepoMockGetMigrationsHistoryParams{limit}
	for _, e := range mmGetMigrationsHistory.expectations {
		if minimock.Equal(e.params, mmGetMigrationsHistory.defaultExpectation.params) {
			mmGetMigrationsHistory.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMigrationsHistory.defaultExpectation.params)
		}
	}

	return mmGetMigrationsHistory
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.GetMigrationsHistory
func (mmGetMigrationsHistory *mMigrationRepoMockGetMigrationsHistory) Inspect(f func(limit int)) *mMigrationRepoMockGetMigrationsHistory {
	if mmGetMigrationsHistory.mock.inspectFuncGetMigrationsHistory != nil {
		mmGetMigrationsHistory.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.GetMigrationsHistory")
	}

	mmGetMigrationsHistory.mock.inspectFuncGetMigrationsHistory = f

	return mmGetMigrationsHistory
}

// Return sets up results that will be returned by MigrationRepo.GetMigrationsHistory
func (mmGetMigrationsHistory *mMigrationRepoMockGetMigrationsHistory) Return(m1 MigrationRecords, err error) *MigrationRepoMock {
	if mmGetMigrationsHistory.mock.funcGetMigrationsHistory != nil {
		mmGetMigrationsHistory.mock.t.Fatalf("MigrationRepoMock.GetMigrationsHistory mock is already set by Set")
	}

	if mmGetMigrationsHistory.defaultExpectation == nil {
		mmGetMigrationsHistory.defaultExpectation = &MigrationRepoMockGetMigrationsHistoryExpectation{mock: mmGetMigrationsHistory.mock}
	}
	mmGetMigrationsHistory.defaultExpectation.results = &MigrationRepoMockGetMigrationsHistoryResults{m1, err}
	return mmGetMigrationsHistory.mock
}

//Set uses given function f to mock the MigrationRepo.GetMigrationsHistory method
func (mmGetMigrationsHistory *mMigrationRepoMockGetMigrationsHistory) Set(f func(limit int) (m1 MigrationRecords, err error)) *MigrationRepoMock {
	if mmGetMigrationsHistory.defaultExpectation != nil {
		mmGetMigrationsHistory.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.GetMigrationsHistory method")
	}

	if len(mmGetMigrationsHistory.expectations) > 0 {
		mmGetMigrationsHistory.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.GetMigrationsHistory method")
	}

	mmGetMigrationsHistory.mock.funcGetMigrationsHistory = f
	return mmGetMigrationsHistory.mock
}

// When sets expectation for the MigrationRepo.GetMigrationsHistory which will trigger the result defined by the following
// Then helper
func (mmGetMigrationsHistory *mMigrationRepoMockGetMigrationsHistory) When(limit int) *MigrationRepoMockGetMigrationsHistoryExpectation {
	if mmGetMigrationsHistory.mock.funcGetMigrationsHistory != nil {
		mmGetMigrationsHistory.mock.t.Fatalf("MigrationRepoMock.GetMigrationsHistory mock is already set by Set")
	}

	expectation := &MigrationRepoMockGetMigrationsHistoryExpectation{
		mock:   mmGetMigrationsHistory.mock,
		params: &MigrationRepoMockGetMigrationsHistoryParams{limit},
	}
	mmGetMigrationsHistory.expectations = append(mmGetMigrationsHistory.expectations, expectation)
	return expectation
}

// Then sets up MigrationRepo.GetMigrationsHistory return parameters for the expectation previously defined by the When method
func (e *MigrationRepoMockGetMigrationsHistoryExpectation) Then(m1 MigrationRecords, err error) *MigrationRepoMock {
	e.results = &MigrationRepoMockGetMigrationsHistoryResults{m1, err}
	return e.mock
}

// GetMigrationsHistory implements MigrationRepo
func (mmGetMigrationsHistory *MigrationRepoMock) GetMigrationsHistory(limit int) (m1 MigrationRecords, err error) {
	mm_atomic.AddUint64(&mmGetMigrationsHistory.beforeGetMigrationsHistoryCounter, 1)
	defer mm_atomic.AddUint64(&mmGetMigrationsHistory.afterGetMigrationsHistoryCounter, 1)

	if mmGetMigrationsHistory.inspectFuncGetMigrationsHistory != nil {
		mmGetMigrationsHistory.inspectFuncGetMigrationsHistory(limit)
	}

	mm_params := &MigrationRepoMockGetMigrationsHistoryParams{limit}

	// Record call args
	mmGetMigrationsHistory.GetMigrationsHistoryMock.mutex.Lock()
	mmGetMigrationsHistory.GetMigrationsHistoryMock.callArgs = append(mmGetMigrationsHistory.GetMigrationsHistoryMock.callArgs, mm_params)
	mmGetMigrationsHistory.GetMigrationsHistoryMock.mutex.Unlock()

	for _, e := range mmGetMigrationsHistory.GetMigrationsHistoryMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetMigrationsHistory.GetMigrationsHistoryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMigrationsHistory.GetMigrationsHistoryMock.defaultExpectation.Counter, 1)
		mm_want := mmGetMigrationsHistory.GetMigrationsHistoryMock.defaultExpectation.params
		mm_got := MigrationRepoMockGetMigrationsHistoryParams{limit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMigrationsHistory.t.Errorf("MigrationRepoMock.GetMigrationsHistory got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMigrationsHistory.GetMigrationsHistoryMock.defaultExpectation.results
		if mm_results == nil {
			mmGetMigrationsHistory.t.Fatal("No results are set for the MigrationRepoMock.GetMigrationsHistory")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetMigrationsHistory.funcGetMigrationsHistory != nil {
		return mmGetMigrationsHistory.funcGetMigrationsHistory(limit)
	}
	mmGetMigrationsHistory.t.Fatalf("Unexpected call to MigrationRepoMock.GetMigrationsHistory. %v", limit)
	return
}

// GetMigrationsHistoryAfterCounter returns a count of finished MigrationRepoMock.GetMigrationsHistory invocations
func (mmGetMigrationsHistory *MigrationRepoMock) GetMigrationsHistoryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMigrationsHistory.afterGetMigrationsHistoryCounter)
}

// GetMigrationsHistoryBeforeCounter returns a count of MigrationRepoMock.GetMigrationsHistory invocations
func (mmGetMigrationsHistory *MigrationRepoMock) GetMigrationsHistoryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMigrationsHistory.beforeGetMigrationsHistoryCounter)
}

// Calls returns a list of arguments used in each call to MigrationRepoMock.GetMigrationsHistory.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMigrationsHistory *mMigrationRepoMockGetMigrationsHistory) Calls() []*MigrationRepoMockGetMigrationsHistoryParams {
	mmGetMigrationsHistory.mutex.RLock()

	argCopy := make([]*MigrationRepoMockGetMigrationsHistoryParams, len(mmGetMigrationsHistory.callArgs))
	copy(argCopy, mmGetMigrationsHistory.callArgs)

	mmGetMigrationsHistory.mutex.RUnlock()

	return argCopy
}

// MinimockGetMigrationsHistoryDone returns true if the count of the GetMigrationsHistory invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockGetMigrationsHistoryDone() bool {
	for _, e := range m.GetMigrationsHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMigrationsHistoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMigrationsHistoryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMigrationsHistory != nil && mm_atomic.LoadUint64(&m.afterGetMigrationsHistoryCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetMigrationsHistoryInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockGetMigrationsHistoryInspect() {
	for _, e := range m.GetMigrationsHistoryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationRepoMock.GetMigrationsHistory with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMigrationsHistoryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMigrationsHistoryCounter) < 1 {
		if m.GetMigrationsHistoryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationRepoMock.GetMigrationsHistory")
		} else {
			m.t.Errorf("Expected call to MigrationRepoMock.GetMigrationsHistory with params: %#v", *m.GetMigrationsHistoryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMigrationsHistory != nil && mm_atomic.LoadUint64(&m.afterGetMigrationsHistoryCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.GetMigrationsHistory")
	}
}

type mMigrationRepoMockInsertUnAppliedVersion struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockInsertUnAppliedVersionExpectation
	expectations       []*MigrationRepoMockInsertUnAppliedVersionExpectation

	callArgs []*MigrationRepoMockInsertUnAppliedVersionParams
	mutex    sync.RWMutex
}

// MigrationRepoMockInsertUnAppliedVersionExpectation specifies expectation struct of the MigrationRepo.InsertUnAppliedVersion
type MigrationRepoMockInsertUnAppliedVersionExpectation struct {
	mock    *MigrationRepoMock
	params  *MigrationRepoMockInsertUnAppliedVersionParams
	results *MigrationRepoMockInsertUnAppliedVersionResults
	Counter uint64
}

// MigrationRepoMockInsertUnAppliedVersionParams contains parameters of the MigrationRepo.InsertUnAppliedVersion
type MigrationRepoMockInsertUnAppliedVersionParams struct {
	v string
}

// MigrationRepoMockInsertUnAppliedVersionResults contains results of the MigrationRepo.InsertUnAppliedVersion
type MigrationRepoMockInsertUnAppliedVersionResults struct {
	err error
}

// Expect sets up expected params for MigrationRepo.InsertUnAppliedVersion
func (mmInsertUnAppliedVersion *mMigrationRepoMockInsertUnAppliedVersion) Expect(v string) *mMigrationRepoMockInsertUnAppliedVersion {
	if mmInsertUnAppliedVersion.mock.funcInsertUnAppliedVersion != nil {
		mmInsertUnAppliedVersion.mock.t.Fatalf("MigrationRepoMock.InsertUnAppliedVersion mock is already set by Set")
	}

	if mmInsertUnAppliedVersion.defaultExpectation == nil {
		mmInsertUnAppliedVersion.defaultExpectation = &MigrationRepoMockInsertUnAppliedVersionExpectation{}
	}

	mmInsertUnAppliedVersion.defaultExpectation.params = &MigrationRepoMockInsertUnAppliedVersionParams{v}
	for _, e := range mmInsertUnAppliedVersion.expectations {
		if minimock.Equal(e.params, mmInsertUnAppliedVersion.defaultExpectation.params) {
			mmInsertUnAppliedVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertUnAppliedVersion.defaultExpectation.params)
		}
	}

	return mmInsertUnAppliedVersion
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.InsertUnAppliedVersion
func (mmInsertUnAppliedVersion *mMigrationRepoMockInsertUnAppliedVersion) Inspect(f func(v string)) *mMigrationRepoMockInsertUnAppliedVersion {
	if mmInsertUnAppliedVersion.mock.inspectFuncInsertUnAppliedVersion != nil {
		mmInsertUnAppliedVersion.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.InsertUnAppliedVersion")
	}

	mmInsertUnAppliedVersion.mock.inspectFuncInsertUnAppliedVersion = f

	return mmInsertUnAppliedVersion
}

// Return sets up results that will be returned by MigrationRepo.InsertUnAppliedVersion
func (mmInsertUnAppliedVersion *mMigrationRepoMockInsertUnAppliedVersion) Return(err error) *MigrationRepoMock {
	if mmInsertUnAppliedVersion.mock.funcInsertUnAppliedVersion != nil {
		mmInsertUnAppliedVersion.mock.t.Fatalf("MigrationRepoMock.InsertUnAppliedVersion mock is already set by Set")
	}

	if mmInsertUnAppliedVersion.defaultExpectation == nil {
		mmInsertUnAppliedVersion.defaultExpectation = &MigrationRepoMockInsertUnAppliedVersionExpectation{mock: mmInsertUnAppliedVersion.mock}
	}
	mmInsertUnAppliedVersion.defaultExpectation.results = &MigrationRepoMockInsertUnAppliedVersionResults{err}
	return mmInsertUnAppliedVersion.mock
}

//Set uses given function f to mock the MigrationRepo.InsertUnAppliedVersion method
func (mmInsertUnAppliedVersion *mMigrationRepoMockInsertUnAppliedVersion) Set(f func(v string) (err error)) *MigrationRepoMock {
	if mmInsertUnAppliedVersion.defaultExpectation != nil {
		mmInsertUnAppliedVersion.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.InsertUnAppliedVersion method")
	}

	if len(mmInsertUnAppliedVersion.expectations) > 0 {
		mmInsertUnAppliedVersion.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.InsertUnAppliedVersion method")
	}

	mmInsertUnAppliedVersion.mock.funcInsertUnAppliedVersion = f
	return mmInsertUnAppliedVersion.mock
}

// When sets expectation for the MigrationRepo.InsertUnAppliedVersion which will trigger the result defined by the following
// Then helper
func (mmInsertUnAppliedVersion *mMigrationRepoMockInsertUnAppliedVersion) When(v string) *MigrationRepoMockInsertUnAppliedVersionExpectation {
	if mmInsertUnAppliedVersion.mock.funcInsertUnAppliedVersion != nil {
		mmInsertUnAppliedVersion.mock.t.Fatalf("MigrationRepoMock.InsertUnAppliedVersion mock is already set by Set")
	}

	expectation := &MigrationRepoMockInsertUnAppliedVersionExpectation{
		mock:   mmInsertUnAppliedVersion.mock,
		params: &MigrationRepoMockInsertUnAppliedVersionParams{v},
	}
	mmInsertUnAppliedVersion.expectations = append(mmInsertUnAppliedVersion.expectations, expectation)
	return expectation
}

// Then sets up MigrationRepo.InsertUnAppliedVersion return parameters for the expectation previously defined by the When method
func (e *MigrationRepoMockInsertUnAppliedVersionExpectation) Then(err error) *MigrationRepoMock {
	e.results = &MigrationRepoMockInsertUnAppliedVersionResults{err}
	return e.mock
}

// InsertUnAppliedVersion implements MigrationRepo
func (mmInsertUnAppliedVersion *MigrationRepoMock) InsertUnAppliedVersion(v string) (err error) {
	mm_atomic.AddUint64(&mmInsertUnAppliedVersion.beforeInsertUnAppliedVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertUnAppliedVersion.afterInsertUnAppliedVersionCounter, 1)

	if mmInsertUnAppliedVersion.inspectFuncInsertUnAppliedVersion != nil {
		mmInsertUnAppliedVersion.inspectFuncInsertUnAppliedVersion(v)
	}

	mm_params := &MigrationRepoMockInsertUnAppliedVersionParams{v}

	// Record call args
	mmInsertUnAppliedVersion.InsertUnAppliedVersionMock.mutex.Lock()
	mmInsertUnAppliedVersion.InsertUnAppliedVersionMock.callArgs = append(mmInsertUnAppliedVersion.InsertUnAppliedVersionMock.callArgs, mm_params)
	mmInsertUnAppliedVersion.InsertUnAppliedVersionMock.mutex.Unlock()

	for _, e := range mmInsertUnAppliedVersion.InsertUnAppliedVersionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertUnAppliedVersion.InsertUnAppliedVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertUnAppliedVersion.InsertUnAppliedVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertUnAppliedVersion.InsertUnAppliedVersionMock.defaultExpectation.params
		mm_got := MigrationRepoMockInsertUnAppliedVersionParams{v}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertUnAppliedVersion.t.Errorf("MigrationRepoMock.InsertUnAppliedVersion got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertUnAppliedVersion.InsertUnAppliedVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertUnAppliedVersion.t.Fatal("No results are set for the MigrationRepoMock.InsertUnAppliedVersion")
		}
		return (*mm_results).err
	}
	if mmInsertUnAppliedVersion.funcInsertUnAppliedVersion != nil {
		return mmInsertUnAppliedVersion.funcInsertUnAppliedVersion(v)
	}
	mmInsertUnAppliedVersion.t.Fatalf("Unexpected call to MigrationRepoMock.InsertUnAppliedVersion. %v", v)
	return
}

// InsertUnAppliedVersionAfterCounter returns a count of finished MigrationRepoMock.InsertUnAppliedVersion invocations
func (mmInsertUnAppliedVersion *MigrationRepoMock) InsertUnAppliedVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertUnAppliedVersion.afterInsertUnAppliedVersionCounter)
}

// InsertUnAppliedVersionBeforeCounter returns a count of MigrationRepoMock.InsertUnAppliedVersion invocations
func (mmInsertUnAppliedVersion *MigrationRepoMock) InsertUnAppliedVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertUnAppliedVersion.beforeInsertUnAppliedVersionCounter)
}

// Calls returns a list of arguments used in each call to MigrationRepoMock.InsertUnAppliedVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertUnAppliedVersion *mMigrationRepoMockInsertUnAppliedVersion) Calls() []*MigrationRepoMockInsertUnAppliedVersionParams {
	mmInsertUnAppliedVersion.mutex.RLock()

	argCopy := make([]*MigrationRepoMockInsertUnAppliedVersionParams, len(mmInsertUnAppliedVersion.callArgs))
	copy(argCopy, mmInsertUnAppliedVersion.callArgs)

	mmInsertUnAppliedVersion.mutex.RUnlock()

	return argCopy
}

// MinimockInsertUnAppliedVersionDone returns true if the count of the InsertUnAppliedVersion invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockInsertUnAppliedVersionDone() bool {
	for _, e := range m.InsertUnAppliedVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertUnAppliedVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertUnAppliedVersionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertUnAppliedVersion != nil && mm_atomic.LoadUint64(&m.afterInsertUnAppliedVersionCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertUnAppliedVersionInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockInsertUnAppliedVersionInspect() {
	for _, e := range m.InsertUnAppliedVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationRepoMock.InsertUnAppliedVersion with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertUnAppliedVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertUnAppliedVersionCounter) < 1 {
		if m.InsertUnAppliedVersionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationRepoMock.InsertUnAppliedVersion")
		} else {
			m.t.Errorf("Expected call to MigrationRepoMock.InsertUnAppliedVersion with params: %#v", *m.InsertUnAppliedVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertUnAppliedVersion != nil && mm_atomic.LoadUint64(&m.afterInsertUnAppliedVersionCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.InsertUnAppliedVersion")
	}
}

type mMigrationRepoMockInsertVersion struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockInsertVersionExpectation
	expectations       []*MigrationRepoMockInsertVersionExpectation

	callArgs []*MigrationRepoMockInsertVersionParams
	mutex    sync.RWMutex
}

// MigrationRepoMockInsertVersionExpectation specifies expectation struct of the MigrationRepo.InsertVersion
type MigrationRepoMockInsertVersionExpectation struct {
	mock    *MigrationRepoMock
	params  *MigrationRepoMockInsertVersionParams
	results *MigrationRepoMockInsertVersionResults
	Counter uint64
}

// MigrationRepoMockInsertVersionParams contains parameters of the MigrationRepo.InsertVersion
type MigrationRepoMockInsertVersionParams struct {
	v string
}

// MigrationRepoMockInsertVersionResults contains results of the MigrationRepo.InsertVersion
type MigrationRepoMockInsertVersionResults struct {
	err error
}

// Expect sets up expected params for MigrationRepo.InsertVersion
func (mmInsertVersion *mMigrationRepoMockInsertVersion) Expect(v string) *mMigrationRepoMockInsertVersion {
	if mmInsertVersion.mock.funcInsertVersion != nil {
		mmInsertVersion.mock.t.Fatalf("MigrationRepoMock.InsertVersion mock is already set by Set")
	}

	if mmInsertVersion.defaultExpectation == nil {
		mmInsertVersion.defaultExpectation = &MigrationRepoMockInsertVersionExpectation{}
	}

	mmInsertVersion.defaultExpectation.params = &MigrationRepoMockInsertVersionParams{v}
	for _, e := range mmInsertVersion.expectations {
		if minimock.Equal(e.params, mmInsertVersion.defaultExpectation.params) {
			mmInsertVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertVersion.defaultExpectation.params)
		}
	}

	return mmInsertVersion
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.InsertVersion
func (mmInsertVersion *mMigrationRepoMockInsertVersion) Inspect(f func(v string)) *mMigrationRepoMockInsertVersion {
	if mmInsertVersion.mock.inspectFuncInsertVersion != nil {
		mmInsertVersion.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.InsertVersion")
	}

	mmInsertVersion.mock.inspectFuncInsertVersion = f

	return mmInsertVersion
}

// Return sets up results that will be returned by MigrationRepo.InsertVersion
func (mmInsertVersion *mMigrationRepoMockInsertVersion) Return(err error) *MigrationRepoMock {
	if mmInsertVersion.mock.funcInsertVersion != nil {
		mmInsertVersion.mock.t.Fatalf("MigrationRepoMock.InsertVersion mock is already set by Set")
	}

	if mmInsertVersion.defaultExpectation == nil {
		mmInsertVersion.defaultExpectation = &MigrationRepoMockInsertVersionExpectation{mock: mmInsertVersion.mock}
	}
	mmInsertVersion.defaultExpectation.results = &MigrationRepoMockInsertVersionResults{err}
	return mmInsertVersion.mock
}

//Set uses given function f to mock the MigrationRepo.InsertVersion method
func (mmInsertVersion *mMigrationRepoMockInsertVersion) Set(f func(v string) (err error)) *MigrationRepoMock {
	if mmInsertVersion.defaultExpectation != nil {
		mmInsertVersion.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.InsertVersion method")
	}

	if len(mmInsertVersion.expectations) > 0 {
		mmInsertVersion.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.InsertVersion method")
	}

	mmInsertVersion.mock.funcInsertVersion = f
	return mmInsertVersion.mock
}

// When sets expectation for the MigrationRepo.InsertVersion which will trigger the result defined by the following
// Then helper
func (mmInsertVersion *mMigrationRepoMockInsertVersion) When(v string) *MigrationRepoMockInsertVersionExpectation {
	if mmInsertVersion.mock.funcInsertVersion != nil {
		mmInsertVersion.mock.t.Fatalf("MigrationRepoMock.InsertVersion mock is already set by Set")
	}

	expectation := &MigrationRepoMockInsertVersionExpectation{
		mock:   mmInsertVersion.mock,
		params: &MigrationRepoMockInsertVersionParams{v},
	}
	mmInsertVersion.expectations = append(mmInsertVersion.expectations, expectation)
	return expectation
}

// Then sets up MigrationRepo.InsertVersion return parameters for the expectation previously defined by the When method
func (e *MigrationRepoMockInsertVersionExpectation) Then(err error) *MigrationRepoMock {
	e.results = &MigrationRepoMockInsertVersionResults{err}
	return e.mock
}

// InsertVersion implements MigrationRepo
func (mmInsertVersion *MigrationRepoMock) InsertVersion(v string) (err error) {
	mm_atomic.AddUint64(&mmInsertVersion.beforeInsertVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmInsertVersion.afterInsertVersionCounter, 1)

	if mmInsertVersion.inspectFuncInsertVersion != nil {
		mmInsertVersion.inspectFuncInsertVersion(v)
	}

	mm_params := &MigrationRepoMockInsertVersionParams{v}

	// Record call args
	mmInsertVersion.InsertVersionMock.mutex.Lock()
	mmInsertVersion.InsertVersionMock.callArgs = append(mmInsertVersion.InsertVersionMock.callArgs, mm_params)
	mmInsertVersion.InsertVersionMock.mutex.Unlock()

	for _, e := range mmInsertVersion.InsertVersionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInsertVersion.InsertVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertVersion.InsertVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmInsertVersion.InsertVersionMock.defaultExpectation.params
		mm_got := MigrationRepoMockInsertVersionParams{v}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertVersion.t.Errorf("MigrationRepoMock.InsertVersion got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertVersion.InsertVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmInsertVersion.t.Fatal("No results are set for the MigrationRepoMock.InsertVersion")
		}
		return (*mm_results).err
	}
	if mmInsertVersion.funcInsertVersion != nil {
		return mmInsertVersion.funcInsertVersion(v)
	}
	mmInsertVersion.t.Fatalf("Unexpected call to MigrationRepoMock.InsertVersion. %v", v)
	return
}

// InsertVersionAfterCounter returns a count of finished MigrationRepoMock.InsertVersion invocations
func (mmInsertVersion *MigrationRepoMock) InsertVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertVersion.afterInsertVersionCounter)
}

// InsertVersionBeforeCounter returns a count of MigrationRepoMock.InsertVersion invocations
func (mmInsertVersion *MigrationRepoMock) InsertVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertVersion.beforeInsertVersionCounter)
}

// Calls returns a list of arguments used in each call to MigrationRepoMock.InsertVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertVersion *mMigrationRepoMockInsertVersion) Calls() []*MigrationRepoMockInsertVersionParams {
	mmInsertVersion.mutex.RLock()

	argCopy := make([]*MigrationRepoMockInsertVersionParams, len(mmInsertVersion.callArgs))
	copy(argCopy, mmInsertVersion.callArgs)

	mmInsertVersion.mutex.RUnlock()

	return argCopy
}

// MinimockInsertVersionDone returns true if the count of the InsertVersion invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockInsertVersionDone() bool {
	for _, e := range m.InsertVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertVersionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertVersion != nil && mm_atomic.LoadUint64(&m.afterInsertVersionCounter) < 1 {
		return false
	}
	return true
}

// MinimockInsertVersionInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockInsertVersionInspect() {
	for _, e := range m.InsertVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationRepoMock.InsertVersion with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertVersionCounter) < 1 {
		if m.InsertVersionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationRepoMock.InsertVersion")
		} else {
			m.t.Errorf("Expected call to MigrationRepoMock.InsertVersion with params: %#v", *m.InsertVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertVersion != nil && mm_atomic.LoadUint64(&m.afterInsertVersionCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.InsertVersion")
	}
}

type mMigrationRepoMockLockVersion struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockLockVersionExpectation
	expectations       []*MigrationRepoMockLockVersionExpectation

	callArgs []*MigrationRepoMockLockVersionParams
	mutex    sync.RWMutex
}

// MigrationRepoMockLockVersionExpectation specifies expectation struct of the MigrationRepo.LockVersion
type MigrationRepoMockLockVersionExpectation struct {
	mock    *MigrationRepoMock
	params  *MigrationRepoMockLockVersionParams
	results *MigrationRepoMockLockVersionResults
	Counter uint64
}

// MigrationRepoMockLockVersionParams contains parameters of the MigrationRepo.LockVersion
type MigrationRepoMockLockVersionParams struct {
	v string
}

// MigrationRepoMockLockVersionResults contains results of the MigrationRepo.LockVersion
type MigrationRepoMockLockVersionResults struct {
	err error
}

// Expect sets up expected params for MigrationRepo.LockVersion
func (mmLockVersion *mMigrationRepoMockLockVersion) Expect(v string) *mMigrationRepoMockLockVersion {
	if mmLockVersion.mock.funcLockVersion != nil {
		mmLockVersion.mock.t.Fatalf("MigrationRepoMock.LockVersion mock is already set by Set")
	}

	if mmLockVersion.defaultExpectation == nil {
		mmLockVersion.defaultExpectation = &MigrationRepoMockLockVersionExpectation{}
	}

	mmLockVersion.defaultExpectation.params = &MigrationRepoMockLockVersionParams{v}
	for _, e := range mmLockVersion.expectations {
		if minimock.Equal(e.params, mmLockVersion.defaultExpectation.params) {
			mmLockVersion.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLockVersion.defaultExpectation.params)
		}
	}

	return mmLockVersion
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.LockVersion
func (mmLockVersion *mMigrationRepoMockLockVersion) Inspect(f func(v string)) *mMigrationRepoMockLockVersion {
	if mmLockVersion.mock.inspectFuncLockVersion != nil {
		mmLockVersion.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.LockVersion")
	}

	mmLockVersion.mock.inspectFuncLockVersion = f

	return mmLockVersion
}

// Return sets up results that will be returned by MigrationRepo.LockVersion
func (mmLockVersion *mMigrationRepoMockLockVersion) Return(err error) *MigrationRepoMock {
	if mmLockVersion.mock.funcLockVersion != nil {
		mmLockVersion.mock.t.Fatalf("MigrationRepoMock.LockVersion mock is already set by Set")
	}

	if mmLockVersion.defaultExpectation == nil {
		mmLockVersion.defaultExpectation = &MigrationRepoMockLockVersionExpectation{mock: mmLockVersion.mock}
	}
	mmLockVersion.defaultExpectation.results = &MigrationRepoMockLockVersionResults{err}
	return mmLockVersion.mock
}

//Set uses given function f to mock the MigrationRepo.LockVersion method
func (mmLockVersion *mMigrationRepoMockLockVersion) Set(f func(v string) (err error)) *MigrationRepoMock {
	if mmLockVersion.defaultExpectation != nil {
		mmLockVersion.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.LockVersion method")
	}

	if len(mmLockVersion.expectations) > 0 {
		mmLockVersion.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.LockVersion method")
	}

	mmLockVersion.mock.funcLockVersion = f
	return mmLockVersion.mock
}

// When sets expectation for the MigrationRepo.LockVersion which will trigger the result defined by the following
// Then helper
func (mmLockVersion *mMigrationRepoMockLockVersion) When(v string) *MigrationRepoMockLockVersionExpectation {
	if mmLockVersion.mock.funcLockVersion != nil {
		mmLockVersion.mock.t.Fatalf("MigrationRepoMock.LockVersion mock is already set by Set")
	}

	expectation := &MigrationRepoMockLockVersionExpectation{
		mock:   mmLockVersion.mock,
		params: &MigrationRepoMockLockVersionParams{v},
	}
	mmLockVersion.expectations = append(mmLockVersion.expectations, expectation)
	return expectation
}

// Then sets up MigrationRepo.LockVersion return parameters for the expectation previously defined by the When method
func (e *MigrationRepoMockLockVersionExpectation) Then(err error) *MigrationRepoMock {
	e.results = &MigrationRepoMockLockVersionResults{err}
	return e.mock
}

// LockVersion implements MigrationRepo
func (mmLockVersion *MigrationRepoMock) LockVersion(v string) (err error) {
	mm_atomic.AddUint64(&mmLockVersion.beforeLockVersionCounter, 1)
	defer mm_atomic.AddUint64(&mmLockVersion.afterLockVersionCounter, 1)

	if mmLockVersion.inspectFuncLockVersion != nil {
		mmLockVersion.inspectFuncLockVersion(v)
	}

	mm_params := &MigrationRepoMockLockVersionParams{v}

	// Record call args
	mmLockVersion.LockVersionMock.mutex.Lock()
	mmLockVersion.LockVersionMock.callArgs = append(mmLockVersion.LockVersionMock.callArgs, mm_params)
	mmLockVersion.LockVersionMock.mutex.Unlock()

	for _, e := range mmLockVersion.LockVersionMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLockVersion.LockVersionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLockVersion.LockVersionMock.defaultExpectation.Counter, 1)
		mm_want := mmLockVersion.LockVersionMock.defaultExpectation.params
		mm_got := MigrationRepoMockLockVersionParams{v}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLockVersion.t.Errorf("MigrationRepoMock.LockVersion got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLockVersion.LockVersionMock.defaultExpectation.results
		if mm_results == nil {
			mmLockVersion.t.Fatal("No results are set for the MigrationRepoMock.LockVersion")
		}
		return (*mm_results).err
	}
	if mmLockVersion.funcLockVersion != nil {
		return mmLockVersion.funcLockVersion(v)
	}
	mmLockVersion.t.Fatalf("Unexpected call to MigrationRepoMock.LockVersion. %v", v)
	return
}

// LockVersionAfterCounter returns a count of finished MigrationRepoMock.LockVersion invocations
func (mmLockVersion *MigrationRepoMock) LockVersionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLockVersion.afterLockVersionCounter)
}

// LockVersionBeforeCounter returns a count of MigrationRepoMock.LockVersion invocations
func (mmLockVersion *MigrationRepoMock) LockVersionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLockVersion.beforeLockVersionCounter)
}

// Calls returns a list of arguments used in each call to MigrationRepoMock.LockVersion.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLockVersion *mMigrationRepoMockLockVersion) Calls() []*MigrationRepoMockLockVersionParams {
	mmLockVersion.mutex.RLock()

	argCopy := make([]*MigrationRepoMockLockVersionParams, len(mmLockVersion.callArgs))
	copy(argCopy, mmLockVersion.callArgs)

	mmLockVersion.mutex.RUnlock()

	return argCopy
}

// MinimockLockVersionDone returns true if the count of the LockVersion invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockLockVersionDone() bool {
	for _, e := range m.LockVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockVersionCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLockVersion != nil && mm_atomic.LoadUint64(&m.afterLockVersionCounter) < 1 {
		return false
	}
	return true
}

// MinimockLockVersionInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockLockVersionInspect() {
	for _, e := range m.LockVersionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationRepoMock.LockVersion with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LockVersionMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLockVersionCounter) < 1 {
		if m.LockVersionMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationRepoMock.LockVersion")
		} else {
			m.t.Errorf("Expected call to MigrationRepoMock.LockVersion with params: %#v", *m.LockVersionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLockVersion != nil && mm_atomic.LoadUint64(&m.afterLockVersionCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.LockVersion")
	}
}

type mMigrationRepoMockUpdateApplyTime struct {
	mock               *MigrationRepoMock
	defaultExpectation *MigrationRepoMockUpdateApplyTimeExpectation
	expectations       []*MigrationRepoMockUpdateApplyTimeExpectation

	callArgs []*MigrationRepoMockUpdateApplyTimeParams
	mutex    sync.RWMutex
}

// MigrationRepoMockUpdateApplyTimeExpectation specifies expectation struct of the MigrationRepo.UpdateApplyTime
type MigrationRepoMockUpdateApplyTimeExpectation struct {
	mock    *MigrationRepoMock
	params  *MigrationRepoMockUpdateApplyTimeParams
	results *MigrationRepoMockUpdateApplyTimeResults
	Counter uint64
}

// MigrationRepoMockUpdateApplyTimeParams contains parameters of the MigrationRepo.UpdateApplyTime
type MigrationRepoMockUpdateApplyTimeParams struct {
	v string
}

// MigrationRepoMockUpdateApplyTimeResults contains results of the MigrationRepo.UpdateApplyTime
type MigrationRepoMockUpdateApplyTimeResults struct {
	err error
}

// Expect sets up expected params for MigrationRepo.UpdateApplyTime
func (mmUpdateApplyTime *mMigrationRepoMockUpdateApplyTime) Expect(v string) *mMigrationRepoMockUpdateApplyTime {
	if mmUpdateApplyTime.mock.funcUpdateApplyTime != nil {
		mmUpdateApplyTime.mock.t.Fatalf("MigrationRepoMock.UpdateApplyTime mock is already set by Set")
	}

	if mmUpdateApplyTime.defaultExpectation == nil {
		mmUpdateApplyTime.defaultExpectation = &MigrationRepoMockUpdateApplyTimeExpectation{}
	}

	mmUpdateApplyTime.defaultExpectation.params = &MigrationRepoMockUpdateApplyTimeParams{v}
	for _, e := range mmUpdateApplyTime.expectations {
		if minimock.Equal(e.params, mmUpdateApplyTime.defaultExpectation.params) {
			mmUpdateApplyTime.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateApplyTime.defaultExpectation.params)
		}
	}

	return mmUpdateApplyTime
}

// Inspect accepts an inspector function that has same arguments as the MigrationRepo.UpdateApplyTime
func (mmUpdateApplyTime *mMigrationRepoMockUpdateApplyTime) Inspect(f func(v string)) *mMigrationRepoMockUpdateApplyTime {
	if mmUpdateApplyTime.mock.inspectFuncUpdateApplyTime != nil {
		mmUpdateApplyTime.mock.t.Fatalf("Inspect function is already set for MigrationRepoMock.UpdateApplyTime")
	}

	mmUpdateApplyTime.mock.inspectFuncUpdateApplyTime = f

	return mmUpdateApplyTime
}

// Return sets up results that will be returned by MigrationRepo.UpdateApplyTime
func (mmUpdateApplyTime *mMigrationRepoMockUpdateApplyTime) Return(err error) *MigrationRepoMock {
	if mmUpdateApplyTime.mock.funcUpdateApplyTime != nil {
		mmUpdateApplyTime.mock.t.Fatalf("MigrationRepoMock.UpdateApplyTime mock is already set by Set")
	}

	if mmUpdateApplyTime.defaultExpectation == nil {
		mmUpdateApplyTime.defaultExpectation = &MigrationRepoMockUpdateApplyTimeExpectation{mock: mmUpdateApplyTime.mock}
	}
	mmUpdateApplyTime.defaultExpectation.results = &MigrationRepoMockUpdateApplyTimeResults{err}
	return mmUpdateApplyTime.mock
}

//Set uses given function f to mock the MigrationRepo.UpdateApplyTime method
func (mmUpdateApplyTime *mMigrationRepoMockUpdateApplyTime) Set(f func(v string) (err error)) *MigrationRepoMock {
	if mmUpdateApplyTime.defaultExpectation != nil {
		mmUpdateApplyTime.mock.t.Fatalf("Default expectation is already set for the MigrationRepo.UpdateApplyTime method")
	}

	if len(mmUpdateApplyTime.expectations) > 0 {
		mmUpdateApplyTime.mock.t.Fatalf("Some expectations are already set for the MigrationRepo.UpdateApplyTime method")
	}

	mmUpdateApplyTime.mock.funcUpdateApplyTime = f
	return mmUpdateApplyTime.mock
}

// When sets expectation for the MigrationRepo.UpdateApplyTime which will trigger the result defined by the following
// Then helper
func (mmUpdateApplyTime *mMigrationRepoMockUpdateApplyTime) When(v string) *MigrationRepoMockUpdateApplyTimeExpectation {
	if mmUpdateApplyTime.mock.funcUpdateApplyTime != nil {
		mmUpdateApplyTime.mock.t.Fatalf("MigrationRepoMock.UpdateApplyTime mock is already set by Set")
	}

	expectation := &MigrationRepoMockUpdateApplyTimeExpectation{
		mock:   mmUpdateApplyTime.mock,
		params: &MigrationRepoMockUpdateApplyTimeParams{v},
	}
	mmUpdateApplyTime.expectations = append(mmUpdateApplyTime.expectations, expectation)
	return expectation
}

// Then sets up MigrationRepo.UpdateApplyTime return parameters for the expectation previously defined by the When method
func (e *MigrationRepoMockUpdateApplyTimeExpectation) Then(err error) *MigrationRepoMock {
	e.results = &MigrationRepoMockUpdateApplyTimeResults{err}
	return e.mock
}

// UpdateApplyTime implements MigrationRepo
func (mmUpdateApplyTime *MigrationRepoMock) UpdateApplyTime(v string) (err error) {
	mm_atomic.AddUint64(&mmUpdateApplyTime.beforeUpdateApplyTimeCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateApplyTime.afterUpdateApplyTimeCounter, 1)

	if mmUpdateApplyTime.inspectFuncUpdateApplyTime != nil {
		mmUpdateApplyTime.inspectFuncUpdateApplyTime(v)
	}

	mm_params := &MigrationRepoMockUpdateApplyTimeParams{v}

	// Record call args
	mmUpdateApplyTime.UpdateApplyTimeMock.mutex.Lock()
	mmUpdateApplyTime.UpdateApplyTimeMock.callArgs = append(mmUpdateApplyTime.UpdateApplyTimeMock.callArgs, mm_params)
	mmUpdateApplyTime.UpdateApplyTimeMock.mutex.Unlock()

	for _, e := range mmUpdateApplyTime.UpdateApplyTimeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateApplyTime.UpdateApplyTimeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateApplyTime.UpdateApplyTimeMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateApplyTime.UpdateApplyTimeMock.defaultExpectation.params
		mm_got := MigrationRepoMockUpdateApplyTimeParams{v}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateApplyTime.t.Errorf("MigrationRepoMock.UpdateApplyTime got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateApplyTime.UpdateApplyTimeMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateApplyTime.t.Fatal("No results are set for the MigrationRepoMock.UpdateApplyTime")
		}
		return (*mm_results).err
	}
	if mmUpdateApplyTime.funcUpdateApplyTime != nil {
		return mmUpdateApplyTime.funcUpdateApplyTime(v)
	}
	mmUpdateApplyTime.t.Fatalf("Unexpected call to MigrationRepoMock.UpdateApplyTime. %v", v)
	return
}

// UpdateApplyTimeAfterCounter returns a count of finished MigrationRepoMock.UpdateApplyTime invocations
func (mmUpdateApplyTime *MigrationRepoMock) UpdateApplyTimeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateApplyTime.afterUpdateApplyTimeCounter)
}

// UpdateApplyTimeBeforeCounter returns a count of MigrationRepoMock.UpdateApplyTime invocations
func (mmUpdateApplyTime *MigrationRepoMock) UpdateApplyTimeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateApplyTime.beforeUpdateApplyTimeCounter)
}

// Calls returns a list of arguments used in each call to MigrationRepoMock.UpdateApplyTime.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateApplyTime *mMigrationRepoMockUpdateApplyTime) Calls() []*MigrationRepoMockUpdateApplyTimeParams {
	mmUpdateApplyTime.mutex.RLock()

	argCopy := make([]*MigrationRepoMockUpdateApplyTimeParams, len(mmUpdateApplyTime.callArgs))
	copy(argCopy, mmUpdateApplyTime.callArgs)

	mmUpdateApplyTime.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateApplyTimeDone returns true if the count of the UpdateApplyTime invocations corresponds
// the number of defined expectations
func (m *MigrationRepoMock) MinimockUpdateApplyTimeDone() bool {
	for _, e := range m.UpdateApplyTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateApplyTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateApplyTimeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateApplyTime != nil && mm_atomic.LoadUint64(&m.afterUpdateApplyTimeCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateApplyTimeInspect logs each unmet expectation
func (m *MigrationRepoMock) MinimockUpdateApplyTimeInspect() {
	for _, e := range m.UpdateApplyTimeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MigrationRepoMock.UpdateApplyTime with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateApplyTimeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateApplyTimeCounter) < 1 {
		if m.UpdateApplyTimeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MigrationRepoMock.UpdateApplyTime")
		} else {
			m.t.Errorf("Expected call to MigrationRepoMock.UpdateApplyTime with params: %#v", *m.UpdateApplyTimeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateApplyTime != nil && mm_atomic.LoadUint64(&m.afterUpdateApplyTimeCounter) < 1 {
		m.t.Error("Expected call to MigrationRepoMock.UpdateApplyTime")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MigrationRepoMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateVersionTableInspect()

		m.MinimockDeleteVersionInspect()

		m.MinimockEnsureDBVersionInspect()

		m.MinimockGetDBInspect()

		m.MinimockGetDBVersionInspect()

		m.MinimockGetMigrationsHistoryInspect()

		m.MinimockInsertUnAppliedVersionInspect()

		m.MinimockInsertVersionInspect()

		m.MinimockLockVersionInspect()

		m.MinimockUpdateApplyTimeInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MigrationRepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MigrationRepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateVersionTableDone() &&
		m.MinimockDeleteVersionDone() &&
		m.MinimockEnsureDBVersionDone() &&
		m.MinimockGetDBDone() &&
		m.MinimockGetDBVersionDone() &&
		m.MinimockGetMigrationsHistoryDone() &&
		m.MinimockInsertUnAppliedVersionDone() &&
		m.MinimockInsertVersionDone() &&
		m.MinimockLockVersionDone() &&
		m.MinimockUpdateApplyTimeDone()
}
